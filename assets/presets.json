{
  "presets": {
    "Matrix Rain": {
      "name": "Matrix Rain",
      "category": "FRACTAL PRESETS",
      "code": "/*\n  Feel free to do anything you want with this code.\n  This shader uses \"runes\" code by FabriceNeyret2[](https://www.shadertoy.com/view/4ltyDM)\n  which is based on \"runes\" by otaviogood[](https://shadertoy.com/view/MsXSRn).\n  These random runes look good as matrix symbols and have acceptable performance.\n*/\n\nconst int ITERATIONS = 40;   //use less value if you need more performance\nconst float SPEED = 1.;\n\nconst float STRIP_CHARS_MIN =  7.;\nconst float STRIP_CHARS_MAX = 40.;\nconst float STRIP_CHAR_HEIGHT = 0.15;\nconst float STRIP_CHAR_WIDTH = 0.10;\nconst float ZCELL_SIZE = 1. * (STRIP_CHAR_HEIGHT * STRIP_CHARS_MAX);  //the multiplier can't be less than 1.\nconst float XYCELL_SIZE = 12. * STRIP_CHAR_WIDTH;  //the multiplier can't be less than 1.\n\nconst int BLOCK_SIZE = 10;  //in cells\nconst int BLOCK_GAP = 2;    //in cells\n\nconst float WALK_SPEED = 1. * XYCELL_SIZE;\nconst float BLOCKS_BEFORE_TURN = 3.;\n\n\nconst float PI = 3.14159265359;\n\n\n//        ----  random  ----\n\nfloat hash(float v) {\n    return fract(sin(v)*43758.5453123);\n}\n\nfloat hash(vec2 v) {\n    return hash(dot(v, vec2(5.3983, 5.4427)));\n}\n\nvec2 hash2(vec2 v)\n{\n    v = vec2(v * mat2(127.1, 311.7,  269.5, 183.3));\n\treturn fract(sin(v)*43758.5453123);\n}\n\nvec4 hash4(vec2 v)\n{\n    vec4 p = vec4(v * mat4x2( 127.1, 311.7,\n                              269.5, 183.3,\n                              113.5, 271.9,\n                              246.1, 124.6 ));\n    return fract(sin(p)*43758.5453123);\n}\n\nvec4 hash4(vec3 v)\n{\n    vec4 p = vec4(v * mat4x3( 127.1, 311.7, 74.7,\n                              269.5, 183.3, 246.1,\n                              113.5, 271.9, 124.6,\n                              271.9, 269.5, 311.7 ) );\n    return fract(sin(p)*43758.5453123);\n}\n\n\n//        ----  symbols  ----\n//  Slightly modified version of \"runes\" by FabriceNeyret2 -  https://www.shadertoy.com/view/4ltyDM\n//  Which is based on \"runes\" by otaviogood -  https://shadertoy.com/view/MsXSRn\n\nfloat rune_line(vec2 p, vec2 a, vec2 b) {   // from https://www.shadertoy.com/view/4dcfW8\n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n\treturn length(p - b * h);                         // dist to segment\n}\n\nfloat rune(vec2 U, vec2 seed, float highlight)\n{\n\tfloat d = 1e5;\n\tfor (int i = 0; i < 4; i++)\t// number of strokes\n\t{\n        vec4 pos = hash4(seed);\n\t\tseed += 1.;\n\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) pos.y = .0;\n\t\tif (i == 1) pos.x = .999;\n\t\tif (i == 2) pos.x = .0;\n\t\tif (i == 3) pos.y = .999;\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec4 snaps = vec4(2, 3, 2, 3);\n\t\tpos = ( floor(pos * snaps) + .5) / snaps;\n\n\t\tif (pos.xy != pos.zw)  //filter out single points (when start and end are the same)\n\t\t    d = min(d, rune_line(U, pos.xy, pos.zw + .001) ); // closest line\n\t}\n\treturn smoothstep(0.1, 0., d) + highlight*smoothstep(0.4, 0., d);\n}\n\nfloat random_char(vec2 outer, vec2 inner, float highlight) {\n    vec2 seed = vec2(dot(outer, vec2(269.5, 183.3)), dot(outer, vec2(113.5, 271.9)));\n    return rune(inner, seed, highlight);\n}\n\n\n//        ----  digital rain  ----\n\n// xy - horizontal, z - vertical\nvec3 rain(vec3 ro3, vec3 rd3, float time) {\n    vec4 result = vec4(0.);\n\n    // normalized 2d projection\n    vec2 ro2 = vec2(ro3);\n    vec2 rd2 = normalize(vec2(rd3));\n\n    // we use formulas `ro3 + rd3 * t3` and `ro2 + rd2 * t2`, `t3_to_t2` is a multiplier to convert t3 to t2\n    bool prefer_dx = abs(rd2.x) > abs(rd2.y);\n    float t3_to_t2 = prefer_dx ? rd3.x / rd2.x : rd3.y / rd2.y;\n\n    // at first, horizontal space (xy) is divided into cells (which are columns in 3D)\n    // then each xy-cell is divided into vertical cells (along z) - each of these cells contains one raindrop\n\n    ivec3 cell_side = ivec3(step(0., rd3));      //for positive rd.x use cell side with higher x (1) as the next side, for negative - with lower x (0), the same for y and z\n    ivec3 cell_shift = ivec3(sign(rd3));         //shift to move to the next cell\n\n    //  move through xy-cells in the ray direction\n    float t2 = 0.;  // the ray formula is: ro2 + rd2 * t2, where t2 is positive as the ray has a direction.\n    ivec2 next_cell = ivec2(floor(ro2/XYCELL_SIZE));  //first cell index where ray origin is located\n    for (int i=0; i<ITERATIONS; i++) {\n        ivec2 cell = next_cell;  //save cell value before changing\n        float t2s = t2;          //and t\n\n        //  find the intersection with the nearest side of the current xy-cell (since we know the direction, we only need to check one vertical side and one horizontal side)\n        vec2 side = vec2(next_cell + cell_side.xy) * XYCELL_SIZE;  //side.x is x coord of the y-axis side, side.y - y of the x-axis side\n        vec2 t2_side = (side - ro2) / rd2;  // t2_side.x and t2_side.y are two candidates for the next value of t2, we need the nearest\n        if (t2_side.x < t2_side.y) {\n            t2 = t2_side.x;\n            next_cell.x += cell_shift.x;  //cross through the y-axis side\n        } else {\n            t2 = t2_side.y;\n            next_cell.y += cell_shift.y;  //cross through the x-axis side\n        }\n        //now t2 is the value of the end point in the current cell (and the same point is the start value in the next cell)\n\n        //  gap cells\n        vec2 cell_in_block = fract(vec2(cell) / float(BLOCK_SIZE));\n        float gap = float(BLOCK_GAP) / float(BLOCK_SIZE);\n        if (cell_in_block.x < gap || cell_in_block.y < gap || (cell_in_block.x < (gap+0.1) && cell_in_block.y < (gap+0.1))) {\n            continue;\n        }\n\n        //  return to 3d - we have start and end points of the ray segment inside the column (t3s and t3e)\n        float t3s = t2s / t3_to_t2;\n\n        //  move through z-cells of the current column in the ray direction (don't need much to check, two nearest cells are enough)\n        float pos_z = ro3.z + rd3.z * t3s;\n        float xycell_hash = hash(vec2(cell));\n        float z_shift = xycell_hash*11. - time * (0.5 + xycell_hash * 1.0 + xycell_hash * xycell_hash * 1.0 + pow(xycell_hash, 16.) * 3.0);  //a different z shift for each xy column\n        float char_z_shift = floor(z_shift / STRIP_CHAR_HEIGHT);\n        z_shift = char_z_shift * STRIP_CHAR_HEIGHT;\n        int zcell = int(floor((pos_z - z_shift)/ZCELL_SIZE));  //z-cell index\n        for (int j=0; j<2; j++) {  //2 iterations is enough if camera doesn't look much up or down\n            //  calcaulate coordinates of the target (raindrop)\n            vec4 cell_hash = hash4(vec3(ivec3(cell, zcell)));\n            vec4 cell_hash2 = fract(cell_hash * vec4(127.1, 311.7, 271.9, 124.6));\n\n            float chars_count = cell_hash.w * (STRIP_CHARS_MAX - STRIP_CHARS_MIN) + STRIP_CHARS_MIN;\n            float target_length = chars_count * STRIP_CHAR_HEIGHT;\n            float target_rad = STRIP_CHAR_WIDTH / 2.;\n            float target_z = (float(zcell)*ZCELL_SIZE + z_shift) + cell_hash.z * (ZCELL_SIZE - target_length);\n            vec2 target = vec2(cell) * XYCELL_SIZE + target_rad + cell_hash.xy * (XYCELL_SIZE - target_rad*2.);\n\n            //  We have a line segment (t0,t). Now calculate the distance between line segment and cell target (it's easier in 2d)\n            vec2 s = target - ro2;\n            float tmin = dot(s, rd2);  //tmin - point with minimal distance to target\n            if (tmin >= t2s && tmin <= t2) {\n                float u = s.x * rd2.y - s.y * rd2.x;  //horizontal coord in the matrix strip\n                if (abs(u) < target_rad) {\n                    u = (u/target_rad + 1.) / 2.;\n                    float z = ro3.z + rd3.z * tmin/t3_to_t2;\n                    float v = (z - target_z) / target_length;  //vertical coord in the matrix strip\n                    if (v >= 0.0 && v < 1.0) {\n                        float c = floor(v * chars_count);  //symbol index relative to the start of the strip, with addition of char_z_shift it becomes an index relative to the whole cell\n                        float q = fract(v * chars_count);\n                        vec2 char_hash = hash2(vec2(c+char_z_shift, cell_hash2.x));\n                        if (char_hash.x >= 0.1 || c == 0.) {  //10% of missed symbols\n                            float time_factor = floor(c == 0. ? time*5.0 :  //first symbol is changed fast\n                                    time*(1.0*cell_hash2.z +   //strips are changed sometime with different speed\n                                            cell_hash2.w*cell_hash2.w*4.*pow(char_hash.y, 4.)));  //some symbols in some strips are changed relatively often\n                            float a = random_char(vec2(char_hash.x, time_factor), vec2(u,q), max(1., 3. - c/2.)*0.2);  //alpha\n                            a *= clamp((chars_count - 0.5 - c) / 2., 0., 1.);  //tail fade\n                            if (a > 0.) {\n                                float attenuation = 1. + pow(0.06*tmin/t3_to_t2, 2.);\n                                vec3 col = (c == 0. ? vec3(0.67, 1.0, 0.82) : vec3(0.25, 0.80, 0.40)) / attenuation;\n                                float a1 = result.a;\n                                result.a = a1 + (1. - a1) * a;\n                                result.xyz = (result.xyz * a1 + col * (1. - a1) * a) / result.a;\n                                if (result.a > 0.98)  return result.xyz;\n                            }\n                        }\n                    }\n                }\n            }\n            // not found in this cell - go to next vertical cell\n            zcell += cell_shift.z;\n        }\n        // go to next horizontal cell\n    }\n\n    return result.xyz * result.a;\n}\n\n\n//        ----  main, camera  ----\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n\tfloat c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nvec3 rotateX(vec3 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(1.,0.,0.,0.,c,-s,0.,s,c) * v;\n}\n\nvec3 rotateY(vec3 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(c,0.,-s,0.,1.,0.,s,0.,c) * v;\n}\n\nvec3 rotateZ(vec3 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(c,-s,0.,s,c,0.,0.,0.,1.) * v;\n}\n\nfloat smoothstep1(float x) {\n    return smoothstep(0., 1., x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (STRIP_CHAR_WIDTH > XYCELL_SIZE || STRIP_CHAR_HEIGHT * STRIP_CHARS_MAX > ZCELL_SIZE) {\n        // error\n        fragColor = vec4(1., 0., 0., 1.);\n        return;\n    }\n\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\n    float time = iTime * SPEED;\n\n    const float turn_rad = 0.25 / BLOCKS_BEFORE_TURN;   //0 .. 0.5\n    const float turn_abs_time = (PI/2.*turn_rad) * 1.5;  //multiplier different than 1 means a slow down on turns\n    const float turn_time = turn_abs_time / (1. - 2.*turn_rad + turn_abs_time);  //0..1, but should be <= 0.5\n\n    float level1_size = float(BLOCK_SIZE) * BLOCKS_BEFORE_TURN * XYCELL_SIZE;\n    float level2_size = 4. * level1_size;\n    float gap_size = float(BLOCK_GAP) * XYCELL_SIZE;\n\n    vec3 ro = vec3(gap_size/2., gap_size/2., 0.);\n    vec3 rd = vec3(uv.x, 2.0, uv.y);\n\n    float tq = fract(time / (level2_size*4.) * WALK_SPEED);  //the whole cycle time counter\n    float t8 = fract(tq*4.);  //time counter while walking on one of the four big sides\n    float t1 = fract(t8*8.);  //time counter while walking on one of the eight sides of the big side\n\n    vec2 prev;\n    vec2 dir;\n    if (tq < 0.25) {\n        prev = vec2(0.,0.);\n        dir = vec2(0.,1.);\n    } else if (tq < 0.5) {\n        prev = vec2(0.,1.);\n        dir = vec2(1.,0.);\n    } else if (tq < 0.75) {\n        prev = vec2(1.,1.);\n        dir = vec2(0.,-1.);\n    } else {\n        prev = vec2(1.,0.);\n        dir = vec2(-1.,0.);\n    }\n    float angle = floor(tq * 4.);  //0..4 wich means 0..2*PI\n\n    prev *= 4.;\n\n    const float first_turn_look_angle = 0.4;\n    const float second_turn_drift_angle = 0.5;\n    const float fifth_turn_drift_angle = 0.25;\n\n    vec2 turn;\n    float turn_sign = 0.;\n    vec2 dirL = rotate(dir, -PI/2.);\n    vec2 dirR = -dirL;\n    float up_down = 0.;\n    float rotate_on_turns = 1.;\n    float roll_on_turns = 1.;\n    float add_angel = 0.;\n    if (t8 < 0.125) {\n        turn = dirL;\n        //dir = dir;\n        turn_sign = -1.;\n        angle -= first_turn_look_angle * (max(0., t1 - (1. - turn_time*2.)) / turn_time - max(0., t1 - (1. - turn_time)) / turn_time * 2.5);\n        roll_on_turns = 0.;\n    } else if (t8 < 0.250) {\n        prev += dir;\n        turn = dir;\n        dir = dirL;\n        angle -= 1.;\n        turn_sign = 1.;\n        add_angel += first_turn_look_angle*0.5 + (-first_turn_look_angle*0.5+1.0+second_turn_drift_angle)*t1;\n        rotate_on_turns = 0.;\n        roll_on_turns = 0.;\n    } else if (t8 < 0.375) {\n        prev += dir + dirL;\n        turn = dirR;\n        //dir = dir;\n        turn_sign = 1.;\n        add_angel += second_turn_drift_angle*sqrt(1.-t1);\n        //roll_on_turns = 0.;\n    } else if (t8 < 0.5) {\n        prev += dir + dir + dirL;\n        turn = dirR;\n        dir = dirR;\n        angle += 1.;\n        turn_sign = 0.;\n        up_down = sin(t1*PI) * 0.37;\n    } else if (t8 < 0.625) {\n        prev += dir + dir;\n        turn = dir;\n        dir = dirR;\n        angle += 1.;\n        turn_sign = -1.;\n        up_down = sin(-min(1., t1/(1.-turn_time))*PI) * 0.37;\n    } else if (t8 < 0.750) {\n        prev += dir + dir + dirR;\n        turn = dirL;\n        //dir = dir;\n        turn_sign = -1.;\n        add_angel -= (fifth_turn_drift_angle + 1.) * smoothstep1(t1);\n        rotate_on_turns = 0.;\n        roll_on_turns = 0.;\n    } else if (t8 < 0.875) {\n        prev += dir + dir + dir + dirR;\n        turn = dir;\n        dir = dirL;\n        angle -= 1.;\n        turn_sign = 1.;\n        add_angel -= fifth_turn_drift_angle - smoothstep1(t1) * (fifth_turn_drift_angle * 2. + 1.);\n        rotate_on_turns = 0.;\n        roll_on_turns = 0.;\n    } else {\n        prev += dir + dir + dir;\n        turn = dirR;\n        //dir = dir;\n        turn_sign = 1.;\n        angle += fifth_turn_drift_angle * (1.5*min(1., (1.-t1)/turn_time) - 0.5*smoothstep1(1. - min(1.,t1/(1.-turn_time))));\n    }\n\n    if (iMouse.x > 10. || iMouse.y > 10.) {\n        vec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n        up_down = -0.7 * mouse.y;\n        angle += mouse.x;\n        rotate_on_turns = 1.;\n        roll_on_turns = 0.;\n    } else {\n        angle += add_angel;\n    }\n\n    rd = rotateX(rd, up_down);\n\n    vec2 p;\n    if (turn_sign == 0.) {\n        //  move forward\n        p = prev + dir * (turn_rad + 1. * t1);\n    }\n    else if (t1 > (1. - turn_time)) {\n        //  turn\n        float tr = (t1 - (1. - turn_time)) / turn_time;\n        vec2 c = prev + dir * (1. - turn_rad) + turn * turn_rad;\n        p = c + turn_rad * rotate(dir, (tr - 1.) * turn_sign * PI/2.);\n        angle += tr * turn_sign * rotate_on_turns;\n        rd = rotateY(rd, sin(tr*turn_sign*PI) * 0.2 * roll_on_turns);  //roll\n    }  else  {\n        //  move forward\n        t1 /= (1. - turn_time);\n        p = prev + dir * (turn_rad + (1. - turn_rad*2.) * t1);\n    }\n\n    rd = rotateZ(rd, angle * PI/2.);\n\n    ro.xy += level1_size * p;\n\n    ro += rd * 0.2;\n    rd = normalize(rd);\n\n    vec3 col = rain(ro, rd, time);\n\n    fragColor = vec4(col, 1.);\n}"
    },    
    "mandelbulb": {
      "name": "Mandelbulb 3D",
      "category": "FRACTAL SHADERS",
      "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat stime, ctime;\nvoid ry(inout vec3 p, float a){\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.x = c * q.x + s * q.z;\n\tp.z = -s * q.x + c * q.z;\n}\n\nfloat pixel_size = 0.0;\n\nvec3 mb(vec3 p) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.0;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 7; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n\t\tphi = asin(z.z / r);\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\nvec3 f(vec3 p){\n\try(p, iTime*0.2);\n\treturn mb(p);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float k ){\n\tfloat akuma=1.0,h=0.0;\n\tfloat t = 0.01;\n\tfor(int i=0; i < 50; ++i){\n\t\th=f(ro+rd*t).x;\n\t\tif(h<0.001)return 0.02;\n\t\takuma=min(akuma, k*h/t);\n\t\tt+=clamp(h,0.01,2.0);\n\t}\n\treturn akuma;\n}\n\nvec3 nor( in vec3 pos )\n{\n\tvec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n\t\tf(pos+eps.xyy).x - f(pos-eps.xyy).x,\n\t\tf(pos+eps.yxy).x - f(pos-eps.yxy).x,\n\t\tf(pos+eps.yyx).x - f(pos-eps.yyx).x ) );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat t = 1.0;\n\tfloat res_t = 0.0;\n\tfloat res_d = 1000.0;\n\tvec3 c, res_c;\n\tfloat max_error = 1000.0;\n\tfloat d = 1.0;\n\tfloat pd = 100.0;\n\tfloat os = 0.0;\n\tfloat step = 0.0;\n\tfloat error = 1000.0;\n\t\n\tfor( int i=0; i<48; i++ )\n\t{\n\t\tif( error < pixel_size*0.5 || t > 20.0 )\n\t\t{\n\t\t}\n\t\telse{\n\t\t\tc = f(ro + rd*t);\n\t\t\td = c.x;\n\n\t\t\tif(d > os)\n\t\t\t{\n\t\t\t\tos = 0.4 * d*d/pd;\n\t\t\t\tstep = d + os;\n\t\t\t\tpd = d;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstep =-os; os = 0.0; pd = 100.0; d = 1.0;\n\t\t\t}\n\n\t\t\terror = d / t;\n\n\t\t\tif(error < max_error)\n\t\t\t{\n\t\t\t\tmax_error = error;\n\t\t\t\tres_t = t;\n\t\t\t\tres_c = c;\n\t\t\t}\n\t\t\n\t\t\tt += step;\n\t\t}\n\t}\n\tif( t>20.0 ) res_t=-1.0;\n\treturn vec3(res_t, res_c.y, res_c.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q=fragCoord.xy/iResolution.xy;\n\tvec2 uv = -1.0 + 2.0*q;\n\tuv.x*=iResolution.x/iResolution.y;\n\t\n\tpixel_size = 1.0/(iResolution.x * 3.0);\n\tstime=0.7+0.3*sin(iTime*0.4);\n\tctime=0.7+0.3*cos(iTime*0.4);\n\n\tvec3 ta=vec3(0.0,0.0,0.0);\n\tvec3 ro = vec3(0.0, 3.*stime*ctime, 3.*(1.-stime*ctime));\n\n\tvec3 cf = normalize(ta-ro);\n\tvec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0)));\n\tvec3 cu = normalize(cross(cs,cf));\n\tvec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf);\n\n\tvec3 sundir = normalize(vec3(0.1, 0.8, 0.6));\n\tvec3 sun = vec3(1.64, 1.27, 0.99);\n\tvec3 skycolor = vec3(0.6, 1.5, 1.0);\n\n\tvec3 bg = exp(uv.y-2.0)*vec3(0.4, 1.6, 1.0);\n\n\tfloat halo=clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.0);\n\tvec3 col=bg+vec3(1.0,0.8,0.4)*pow(halo,17.0);\n\n\tvec3 res = intersect(ro, rd);\n\tif(res.x > 0.0){\n\t\tvec3 p = ro + res.x * rd;\n\t\tvec3 n=nor(p);\n\t\tfloat shadow = softshadow(p, sundir, 10.0 );\n\n\t\tfloat dif = max(0.0, dot(n, sundir));\n\t\tfloat sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0)));\n\t\tfloat bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0);\n\t\tfloat spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0));\n\n\t\tvec3 lin = 4.5 * sun * dif * shadow;\n\t\tlin += 0.8 * bac * sun;\n\t\tlin += 0.6 * sky * skycolor*shadow;\n\t\tlin += 3.0 * spe * shadow;\n\n\t\tres.y = pow(clamp(res.y, 0.0, 1.0), 0.55);\n\t\tvec3 tc0 = 0.5 + 0.5 * sin(3.0 + 4.2 * res.y + vec3(0.0, 0.5, 1.0));\n\t\tcol = lin *vec3(0.9, 0.8, 0.6) * 0.2 * tc0;\n\t\tcol=mix(col,bg, 1.0-exp(-0.001*res.x*res.x));\n\t}\n\n\tcol=pow(clamp(col,0.0,1.0),vec3(0.45));\n\tcol=col*0.6+0.4*col*col*(3.0-2.0*col);\n\tcol=mix(col, vec3(dot(col, vec3(0.33))), -0.5);\n\tcol*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n\tfragColor = vec4(col.xyz, 1.0);\n}"
    },

    "spiral_mandala": {
      "name": "Spiral Mandala",
      "category": "SHADER PRESETS",
      "code": "// Spiral Mandala - Shadertoy: mtyGWy\n\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(1.0, 0.5, 0.5);\n    vec3 c = vec3(1.5, 0.5, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n#define rotation(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\nfloat TAU = 2.*3.14159;\n\n// Thanks IQ\nfloat eqTri( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.x = p.x + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n  bool ENABLE_Ripple ;\n vec2 cPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    // distance of current pixel from center\n\tfloat cLength = length(cPos);\n\nENABLE_Ripple=true; // true add ripple\n\t\n    for (float i = 0.0; i < 4.0; i++) {\n    vec3 col2 = vec3(0.);\n   float t = fract(.1 * iTime*0.51);\n   uv *= rotation(3. * TAU * (.3 - clamp(length(uv),0.,.3)));\n\n if(ENABLE_Ripple == false){\n    uv+= (cPos/cLength)*cos(cLength*4.0-iTime*4.0) * 0.53;\n   }\n   float s = -1.;\n   for(float i = 0.; i < 5.; i++){\n     float rad = 1.4 / pow(2.,i) * (.9 - .2 * i);\n     uv *= rotation(-2. * s * (i + 1.) * TAU * t);\n     float tri = eqTri(uv, rad);\n     s *= -1.;\n     col2 += 1.004 / abs(tri);\n   }\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}"
    },

    "electric": {
      "name": "Electric Orbs",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    for(float i = 0.0; i < 8.0; i++) {\n        float angle = time * (0.5 + i * 0.1) + i * 0.8;\n        vec2 pos = vec2(cos(angle), sin(angle)) * 0.5;\n        float d = length(p - pos);\n        \n        float glow = 0.015 / d;\n        vec3 color = vec3(0.2, 0.5 + sin(time + i) * 0.5, 1.0);\n        col += color * glow;\n    }\n    \n    col += vec3(0.5, 0.8, 1.0) * pow(col.b, 2.0);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "tunnel": {
      "name": "Infinite Tunnel",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float angle = atan(p.y, p.x);\n    float radius = length(p);\n    \n    vec2 tuv = vec2(angle / 3.14159, 0.5 / radius);\n    tuv.y -= time * 0.5;\n    tuv.x += time * 0.2;\n    \n    float pattern1 = sin(tuv.x * 20.0) * sin(tuv.y * 20.0);\n    float pattern2 = sin(tuv.x * 15.0 + tuv.y * 15.0);\n    \n    float final = pattern1 * pattern2;\n    final = final * 0.5 + 0.5;\n    \n    vec3 col = vec3(final);\n    col *= vec3(0.2, 0.8, 1.0);\n    col *= 1.0 - radius * 0.6;\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "fractal": {
      "name": "Fractal Noise",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float n = 0.0;\n    float amp = 0.5;\n    vec2 pos = p * 2.0;\n    \n    for(int i = 0; i < 5; i++) {\n        n += noise(pos + time * 0.3) * amp;\n        pos *= 2.0;\n        amp *= 0.5;\n    }\n    \n    vec3 col = vec3(n);\n    col = pow(col, vec3(1.5));\n    col *= vec3(0.5 + sin(time) * 0.5, 0.7, 1.0);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "hexagon": {
      "name": "Hexagon Grid",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvec2 hexCoord(vec2 p) {\n    vec2 r = vec2(1.0, 1.732);\n    vec2 h = r * 0.5;\n    vec2 a = mod(p, r) - h;\n    vec2 b = mod(p - h, r) - h;\n    return dot(a, a) < dot(b, b) ? a : b;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 10.0;\n    p.x *= resolution.x / resolution.y;\n    \n    vec2 hc = hexCoord(p);\n    float d = length(hc);\n    \n    float hex = smoothstep(0.5, 0.48, d);\n    float pulse = sin(d * 3.0 - time * 2.0) * 0.5 + 0.5;\n    \n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 1.0, 1.0) * hex * 0.5;\n    col += vec3(0.0, 0.5, 1.0) * hex * pulse;\n    col += vec3(1.0, 0.0, 1.0) * (1.0 - smoothstep(0.48, 0.5, d)) * 0.5;\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "voronoi": {
      "name": "Voronoi Cells",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvec2 hash2(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = uv * 8.0;\n    p.x *= resolution.x / resolution.y;\n    \n    vec2 gv = fract(p);\n    vec2 id = floor(p);\n    \n    float minDist = 100.0;\n    vec2 minPoint;\n    \n    for(float y = -1.0; y <= 1.0; y++) {\n        for(float x = -1.0; x <= 1.0; x++) {\n            vec2 offset = vec2(x, y);\n            vec2 neighbor = hash2(id + offset);\n            neighbor += offset;\n            neighbor += sin(time + neighbor * 6.28) * 0.3;\n            \n            float dist = length(gv - neighbor);\n            if(dist < minDist) {\n                minDist = dist;\n                minPoint = neighbor;\n            }\n        }\n    }\n    \n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 1.0, 0.5) * (1.0 - minDist);\n    col += vec3(0.0, 0.5, 1.0) * smoothstep(0.02, 0.0, minDist);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "dmt_light": {
      "name": "DMT Light",
      "category": "SHADER PRESETS",
      "code": "// DMT Light - Creative Coding Tutorial\n// Video: https://youtu.be/f4s1h2YETNY\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n    return a + b*cos(6.28318 * (c*t+d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    for (float i = 0.0; i < 8.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.08);\n        d = sin(d*8. + iTime*0.1)/8.;\n        d = abs(d);\n        d = pow(0.005 / d, 1.2);\n        finalColor += col * d;\n    }\n    fragColor = vec4(finalColor, 1.0);\n}"
    },

    "line_light": {
      "name": "Line Light",
      "category": "SHADER PRESETS",
      "code": "// Line Light - Animated Fractal Lines\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.2, 0.5);   // Mauve\n    vec3 b = vec3(1.0, 1.0, 0.0);   // Jaune\n    vec3 c = vec3(0.0, 1.0, 0.0);   // Vert\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n\n        d = sin(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}"
    },
    "cyber_city": {
      "name": "Cyber City",
      "category": "PROCEDURAL CITY",
      "code": "//#define FAST_DESCENT\n\n//#define BLACK_AND_WHITE\n\n\n#ifdef FAST_DESCENT\nconst vec3 cameraDir = normalize(vec3(-2.0, -1.0, -4.0));\nconst float cameraDist = 5.0;\nconst float speed = 3.0;\nconst float zoom = 2.5;\n\nconst vec3 windowColorA = vec3(0.0, 0.0, 1.5);\nconst vec3 windowColorB = vec3(0.5, 1.5, 2.0);\n\nconst float fogOffset = 2.5;\nconst float fogDensity = 0.6;\nconst vec3 fogColor = vec3(0.25, 0.0, 0.3);\n\nconst float lightHeight = 0.5;\nconst float lightSpeed = 0.2;\nconst vec3 lightColorA = vec3(0.6, 0.3, 0.1);\nconst vec3 lightColorB = vec3(0.8, 0.6, 0.4);\n\nconst vec3 signColorA = vec3(0.0, 0.0, 1.5);\nconst vec3 signColorB = vec3(3.0, 3.0, 3.0);\n#else\nconst vec3 cameraDir = normalize(vec3(-2.0, -1.0, -2.0));\nconst float cameraDist = 9.0;\nconst float speed = 1.0;\nconst float zoom = 3.5;\n\nconst vec3 windowColorA = vec3(0.0, 0.0, 1.5);\nconst vec3 windowColorB = vec3(0.5, 1.5, 2.0);\n\nconst float fogOffset = 7.0;\nconst float fogDensity = 0.7;\nconst vec3 fogColor = vec3(0.25, 0.0, 0.3);\n\nconst float lightHeight = 0.0;\nconst float lightSpeed = 0.15;\nconst vec3 lightColorA = vec3(0.6, 0.3, 0.1);\nconst vec3 lightColorB = vec3(0.8, 0.6, 0.4);\n\nconst vec3 signColorA = vec3(0.0, 0.0, 1.5);\nconst vec3 signColorB = vec3(3.0, 3.0, 3.0);\n#endif\n\nconst float tau = 6.283185;\n\n\nfloat hash1(float p) {\n    vec3 p3 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash1(vec2 p2) {\n    p2 = fract(p2 * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec2 p2, float p) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(vec2 p2, float p) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash3(vec2 p2) {\n    vec3 p3 = fract(vec3(p2.xyx) * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec4 hash4(vec2 p2) {\n    vec4 p4 = fract(p2.xyxy * vec4(5.3983, 5.4427, 6.9371, 7.1283));\n    p4 += dot(p4, p4.yxwz + 19.19);\n    return fract((p4.xxxy + p4.yyzz + p4.zwww) * p4.wzyx);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash1(i + vec2(0.0, 0.0)),\n                   hash1(i + vec2(1.0, 0.0)), u.x),\n               mix(hash1(i + vec2(0.0, 1.0)),\n                   hash1(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvec4 castRay(vec3 eye, vec3 ray, vec2 center) {\n    vec2 block = floor(eye.xy);\n    vec3 ri = 1.0 / ray;\n    vec3 rs = sign(ray);\n    vec3 side = 0.5 + 0.5 * rs;\n    vec2 ris = ri.xy * rs.xy;\n    vec2 dis = (block - eye.xy + 0.5 + rs.xy * 0.5) * ri.xy;\n\n    for (int i = 0; i < 16; ++i) {\n        float d = dot(block - center, cameraDir.xy);\n        float height = 3.0 * hash1(block) - 1.0 + 1.5 * d - 0.1 * d * d;\n\n        vec2 lo0 = vec2(block);\n        vec2 loX = vec2(0.45, 0.45);\n        vec2 hi0 = vec2(block + 0.55);\n        vec2 hiX = vec2(0.45, 0.45);\n\n        float dist = 500.0;\n        float face = 0.0;\n\n        {\n            vec4 signHash = hash4(block);\n            vec2 center = vec2(0.2, -0.4) + vec2(0.6, -0.8) * signHash.xy;\n            float width = 0.06 + 0.1 * signHash.w;\n\n            vec3 lo = vec3(center.x - width, 0.55, -100.0);\n            vec3 hi = vec3(center.x + width, 0.99, center.y + width + height);\n\n            float s = step(0.5, signHash.z);\n            lo = vec3(block, 0.0) + mix(lo, lo.yxz, s);\n            hi = vec3(block, 0.0) + mix(hi, hi.yxz, s);\n\n            vec3 wall = mix(hi, lo, side);\n            vec3 t = (wall - eye) * ri;\n\n            vec3 dim = step(t.zxy, t) * step(t.yzx, t);\n            float maxT = dot(dim, t);\n            float maxFace = dim.x - dim.y;\n\n            vec3 p = eye + maxT * ray;\n            dim += step(lo, p) * step(p, hi);\n\n            if (dim.x * dim.y * dim.z > 0.5) {\n                dist = maxT;\n                face = maxFace;\n            }\n        }\n\n        for (int j = 0; j < 5; ++j) {\n            float top = height - 0.4 * float(j);\n            vec3 lo = vec3(lo0 + loX * hash2(block, float(j)), -100.0);\n            vec3 hi = vec3(hi0 + hiX * hash2(block, float(j) + 0.5), top);\n\n            vec3 wall = mix(hi, lo, side);\n            vec3 t = (wall - eye) * ri;\n\n            vec3 dim = step(t.zxy, t) * step(t.yzx, t);\n            float maxT = dot(dim, t);\n            float maxFace = dim.x - dim.y;\n\n            vec3 p = eye + maxT * ray;\n            dim += step(lo, p) * step(p, hi);\n\n            if (dim.x * dim.y * dim.z > 0.5 && maxT < dist) {\n                dist = maxT;\n                face = maxFace;\n            }\n        }\n\n        if (dist < 400.0) {\n            return vec4(dist, height, face, 1.0);\n        }\n\n        float t = eye.z * ri.z;\n        vec3 p = eye - t * ray;\n        vec2 g = p.xy - block;\n\n        vec2 dim = step(dis.xy, dis.yx);\n        dis += dim * ris;\n        block += dim * rs.xy;\n    }\n\n    return vec4(100.0, 0.0, 0.0, 1.0);\n}\n\nvec3 window(float z, vec2 pos, vec2 id) {\n    float windowSize = 0.03 + 0.12 * hash1(id + 0.1);\n    float windowProb = 0.3 + 0.8 * hash1(id + 0.2);\n    float depth = z / windowSize;\n    float level = floor(depth);\n    vec3 colorA = mix(windowColorA, windowColorB, hash3(id));\n    vec3 colorB = mix(windowColorA, windowColorB, hash3(id + 0.1));\n    vec3 color = mix(colorA, colorB, hash1(id, level));\n    color *= 0.3 + 0.7 * smoothstep(0.1, 0.5, noise(20.0 * pos + 100.0 * hash1(level)));\n    color *= smoothstep(windowProb - 0.2, windowProb + 0.2, hash1(id, level + 0.1));\n    return color * (0.5 - 0.5 * cos(tau * depth));\n}\n\nvec3 addLight(vec3 eye, vec3 ray, float res, float time, float height) {\n    vec2 q = eye.xy + ((height - eye.z) / ray.z) * ray.xy;\n\n    float row = floor(q.x + 0.5);\n    time += hash1(row);\n    float col = floor(0.125 * q.y - time);\n\n    float pos = 0.4 + 0.4 * cos(time + tau * hash1(vec2(row, col)));\n    vec3 lightPos = vec3(row, 8.0 * (col + time + pos), height);\n    vec3 lightDir = vec3(0.0, 1.0, 0.0);\n\n    // http://geomalgorithms.com/a07-_distance.html\n    vec3 w = eye - lightPos;\n    float a = dot(ray, ray);\n    float b = dot(ray, lightDir);\n    float c = dot(lightDir, lightDir);\n    float d = dot(ray, w);\n    float e = dot(lightDir, w);\n    float D = a * c - b * b;\n    float s = (b*e - c*d) / D;\n    float t = (a*e - b*d) / D;\n\n    t = max(t, 0.0);\n    float dist = distance(eye + s * ray, lightPos + t * lightDir);\n\n    float mask = smoothstep(res + 0.1, res, s);\n    float light = min(1.0 / pow(200.0 * dist * dist / t + 20.0 * t * t, 0.8), 2.0);\n    float fog = exp(-fogDensity * max(s - fogOffset, 0.0));\n    vec3 color = mix(lightColorA, lightColorB, hash3(vec2(row, col)));\n    return mask * light * fog * color;\n}\n\nvec3 addSign(vec3 color, vec3 pos, float side, vec2 id) {\n    vec4 signHash = hash4(id);\n    float s = step(0.5, signHash.z);\n    if ((s - 0.5) * side < 0.1)\n        return color;\n\n    vec2 center = vec2(0.2, -0.4) + vec2(0.6, -0.8) * signHash.xy;\n    vec2 p = mix(pos.xz, pos.yz, s);\n    float halfWidth = 0.04 + 0.06 * signHash.w;\n\n    float charCount = floor(1.0 + 8.0 * hash1(id + 0.5));\n    if (center.y - p.y > 2.0 * halfWidth * (charCount + 1.0)) {\n        center.y -= 2.0 * halfWidth * (charCount + 1.5 + 5.0 * hash1(id + 0.6));\n        charCount = floor(2.0 + 12.0 * hash1(id + 0.7));\n        id += 0.05;\n    }\n\n    vec3 signColor = mix(signColorA, signColorB, hash3(id + 0.5));\n    vec3 outlineColor = mix(signColorA, signColorB, hash3(id + 0.6));\n    float flash = 6.0 - 24.0 * hash1(id + 0.8);\n    flash *= step(3.0, flash);\n    flash = smoothstep(0.1, 0.5, 0.5 + 0.5 * cos(flash * iTime));\n\n    vec2 halfSize = vec2(halfWidth, halfWidth * charCount);\n    center.y -= halfSize.y;\n    float outline = length(max(abs(p - center) - halfSize, 0.0)) / halfWidth;\n    color *= smoothstep(0.1, 0.4, outline);\n\n    vec2 charPos = 0.5 * (p - center + halfSize) / halfWidth;\n    vec2 charId = id + 0.05 + 0.1 * floor(charPos);\n    float flicker = hash1(charId);\n    flicker = step(0.93, flicker);\n    flicker = 1.0 - flicker * step(0.96, hash1(charId, iTime));\n\n    float char = -3.5 + 8.0 * noise(id + 6.0 * charPos);\n    charPos = fract(charPos);\n    char *= smoothstep(0.0, 0.4, charPos.x) * smoothstep(1.0, 0.6, charPos.x);\n    char *= smoothstep(0.0, 0.4, charPos.y) * smoothstep(1.0, 0.6, charPos.y);\n    color = mix(color, signColor, flash * flicker * step(outline, 0.01) * clamp(char, 0.0, 1.0));\n\n    outline = smoothstep(0.0, 0.2, outline) * smoothstep(0.5, 0.3, outline);\n    return mix(color, outlineColor, flash * outline);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = -speed * iTime * cameraDir.xy;\n    vec3 eye = vec3(center, 0.0) - cameraDist * cameraDir;\n\n    vec3 forward = normalize(cameraDir);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward * iResolution.y);\n\n    vec4 res = castRay(eye, ray, center);\n    vec3 p = eye + res.x * ray;\n\n    vec2 block = floor(p.xy);\n\tvec3 color = window(p.z - res.y, p.xy, block);\n\n    color = addSign(color, vec3(p.xy - block, p.z - res.y), res.z, block);\n    color = mix(vec3(0.0), color, abs(res.z));\n\n    float fog = exp(-fogDensity * max(res.x - fogOffset, 0.0));\n    color = mix(fogColor, color, fog);\n\n    float time = lightSpeed * iTime;\n    color += addLight(eye.xyz, ray.xyz, res.x, time, lightHeight - 0.6);\n    color += addLight(eye.yxz, ray.yxz, res.x, time, lightHeight - 0.4);\n    color += addLight(vec3(-eye.xy, eye.z), vec3(-ray.xy, ray.z), res.x, time, lightHeight - 0.2);\n    color += addLight(vec3(-eye.yx, eye.z), vec3(-ray.yx, ray.z), res.x, time, lightHeight);\n\n#ifdef BLACK_AND_WHITE\n    float c = clamp(dot(vec3(0.4, 0.3, 0.4), color), 0.0, 1.0);\n    c = 1.0 - pow(1.0 - pow(c, 2.0), 4.0);\n    color = vec3(c);\n#endif\n    \n    fragColor = vec4(color, 1.0);\n}"
    },
    "truchet_dual": {
      "name": "Dual 3D Truchet Tiles",
      "category": "PROCEDURAL 3D",
      "code": "/*\n\n\tDual 3D Truchet Tiles\n\t---------------------\n\n\tThis is yet another 3D Truchet example, but it consists of two unique Truchet blocks, which gives \n\tthe pattern a bit more variation. Truchet patterns usually make use of one block, consisting\n\tof three strategically placed tori designed to intersect the centers of all cube faces.\n\n\tThis particular pattern introduces another variation that consists of two tori intersecting four \n\tfaces and a straight segment that runs through opposing faces. The resultant pattern has more of a \n\trandom pipework look -- as opposed to the standard snake-like one. By the way, you could save a \n    lot of extra decision making and use just the second tile, but I feel the pattern lacks a little\n\tvariance when doing that.\n\t\n\tAnyway, apart from some extra decision making and construction, the code doesn't differ too much \n\tfrom regular examples. By the way, I can thank Mattz for reminding me of a concept that I'd forgotten, \n\twhich helped me speed up the distance field equation. Without it, this example would run much slower.\n\tI've described it briefly somewhere in among the distance field setup.\n\n\tWhilst on the subject of optimization, I should probably mention that I often take shortcuts with\n\tthe distance field equations in order to save the GPU extra calculations. For instance, I'll use a \n\tbound, like \"max(max(x, y), z),\" for a cube instead of the correct - but usually more expensive - \n\tone. For the most part, you can get away with it, but things like shadows, etc, can be affected. \n\tIQ has an example that illustrates the point here:\n\n\tRotational symmetry - iq\n\thttps://www.shadertoy.com/view/XtSczV\n\n\t\n\tBased on:\n\n\t// Same concept, but with one tile, which makes it easier to comprehend.\n\tCubic Truchet Pattern - Shane\n\thttps://www.shadertoy.com/view/4lfcRl\n\n\tOther Truchet examples:\n\n\t// 3D Truchet flow. Very cool. If you have easy questions to ask, feel free to send me an email, \n    // but if you have difficult ones, ask Mattz. :)\n\trandom cubic Truchet flow - mattz\n\thttps://www.shadertoy.com/view/MtSyRz\n\n\t// Psuedo 3D version, rendered in an oldschool game style.\n\t2D Pipe Pattern - Shane\n\thttps://www.shadertoy.com/view/XlXBzl\n\n\n*/\n\n\n// Maximum ray distance.\n#define FAR 80.\n\n// Cross-sectional shape.\n// 0, 1, 2, or 3: Round, square, rounded-square or octagonal.\n#define TUBE_SHAPE 3 \n\n// Cheap, last minute camera weave. Suggested by ExNihilo. To implement this properly, I need\n// to add a few lines to set up a proper \"too\" and \"from\" camera... add a camera path function...\n// maybe later. :)\n#define CAMERA_WEAVE\n\n\n// Global storage vectors for object identification: I'm not fond of using globals inside distance field\n// functions, but felt it was necessary in this case.\nvec3 vObjID;\n//float gID; \n\n// Global glow variable. Accumulated in the raymarching function.\nfloat glow;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n// IQ's correct box formula.\nfloat sdBox( vec2 p, float b ){\n  //vec2 d = abs(p) - b; // \"p\" is already in absolute form, in this case.\n  vec2 d = p - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// Tube: Cylindrical tube, square tube, etc. In this case, it's a squarish tube with some\n// beveled sides.\nfloat tube(vec2 p, float sc, float rad){\n    \n    // Normally needed, but in this example \"p\" is passed to the function in its absoluted form.\n    //p = abs(p);\n    \n    \n    #if TUBE_SHAPE == 0\n    \n    return length(p) - rad; // Standard round pipes.\n\n    #elif TUBE_SHAPE == 1\n    \n    // Box shape: I've left the correct and cheap version for comparison. Uncomment each, then\n    // pause and check the shadows. The structure remains the same, but the shadows do not.\n    return sdBox(p, rad); // Correct square distance field equation.\n    //return max(p.x, p.y) - rad; // Cheaper shortcut. Almost the same, but not quite.\n    \n    #elif TUBE_SHAPE == 2\n    // Rounded square tube. Two versions.\n    return smax(p.x, p.y, .015) - rad; // Rounded square. Smooth minimum version.\n    //return pow(dot(pow(p, vec2(8)), vec2(1)), 1./8.) - rad; // Rounded square. Super-elliptical.\n    \n    #else\n    \n    // Ocatagonal shape.\n    return max(max(p.x, p.y), (p.x + p.y)*sc) - rad; // .7071 for an octagon.\n    \n    #endif\n    \n}\n\n\n// The toroidal tube objects. Each consist of a white squarish outer tube, a similar colored \n// inner one (only visible through the holes) and some colored bands.\nvec4 torTube(vec3 p){\n\n\n    // Tube width.\n    const float rad2 = .07;\n    \n    \n    // Main tube. If it were not for the additional tube decorations, the following \n    // would be all that'd be required.\n    //\n    // Note that we're converting one of the coordinates to its circular form. That way, \n    // we're rendering a circular tube, instead of a straight one. It's an oversimplification, \n    // but that's basically all a torus is. By the way, it doesn't have to be circular, \n    // converting \"p.xy\" to an octagonal form, etc, would work also.\n    float tb = tube(abs(vec2(length(p.xy) - .5, p.z)), .75, rad2);\n    \n    \n    // Adding some details to the tube. \n    \n    \n    // Inner tube for colored lights.\n    float innerTb = 1e5; //tb + .0075; \n    \n   \n    \n    // Tube segments - for the bands and holes.\n    //\n    // Number of tube segments. Breaking a circle into 8 lots of 3. Other combinations can\n    // work though.\n    const float aNum = 12.; \n    \n    // Realigning the segments.\n    p.xy = rot2(3.14159/4.)*p.xy;\n    \n    // To place things evenly around the tube, you need to obtain the angle subtended to the center,\n    // partition it into the required number of cells (aNum), then obtain the angle at the center.\n    float a = atan(p.y, p.x);    \n    float ia = floor(a/6.283*aNum) + .5; // .5 to move to the cell center.\n\n    // Converting to polar coordinates - In effect: Radial position, \"p.x,\" and angular position, \"p.y.\"\n    p.xy = rot2(ia*6.283/aNum)*p.xy;\n    // The radial coordinate effective starts off at the center, so to spread the objects out, you have\n    // to advance them  along the radial coordinate in the radial direction. In this case, we want the \n    // objects to have the same radius as the torus we're attaching them to, which is \".5.\"\n    p.x -= .5;\n\n    // Drawing the objects within each of the partitioned cells. In this case, we're rendering some \n    // colored sleeves (or bands), and boring out some holes.\n    \n    p = abs(p);\n    \n    // Bands, or sleeves.\n    float band = max(tube(p.xz, .75,  rad2 + .0075), p.y - .06);\n    vec2 peg = vec2(tube(p.xy, .64, .0425), tube(p.yz, .64, .0425)); \n    \n    \n    // Group the 24 cell partitions into groups of 3 - in order to cover every third cell with the \n    // band and create a portal in the others... I figured it'd break up the monotony. :)\n    // On a side note, I try to avoid \"if\" statements inside distance functions when I can, but I \n    // figured this would be the best way for readability. Although, I might rework it later.\n    if(mod(ia + 1., 3.)>2.){\n        \n        band = min(band, max(tube(p.xz, .6, rad2 + .015), p.y - .04));\n    \t//band = max(band, min(band + .005, -p.y + .015));\n        band = min(band, max(tube(p.xz, .6, rad2 + .025), p.y - .04/3.));\n    }\n    else {\n        \n        // Portals on alternate bands.\n        \n        float hole = min(peg.x, peg.y);\n        \n        // Octagonal portal flush. The rest are raised a little. No reason. Just a design choice.\n        #if TUBE_SHAPE == 3\n        band = min(band, min(max(peg.x, p.z - rad2 - .0075), max(peg.y, p.x - rad2 - .0075)));\n        #else \n        band = min(band, min(max(peg.x, p.z - rad2 - .02), max(peg.y, p.x - rad2 - .02)));\n        #endif\n        band = max(band, -(hole + .015));\n        \n        tb = max(tb, -(hole + .015));\n        \n        // Inner tube. Actually, just some spheres at the portal positions, but to the observer,\n        // it gives the impression of an inner tube.\n        innerTb = length(p) - rad2 + .01;\n        \n    }\n    \n    \n    \n    // Return the tube, bands, and inner tube objects.\n    return vec4(tb, band, innerTb, ia);\n}\n\n\n\n\n// The toroidal tube objects. Each consist of a white squarish outer tube, a similar colored \n// inner one (only visible through the holes) and some colored bands.\nvec4 straightTube(vec3 p){\n    \n    \n    // Tube width.\n    const float rad2 = .07;\n    \n    \n    // Main tube. If it were not for the additional tube decorations, the following \n    // would be all that'd be required.\n    float tb = tube(abs(p.xy), .75, rad2);\n    \n    \n    // Inner tube for colored lights.\n    float innerTb = 1e5; //tb + .0075; \n    \n    \n    // Adding some details to the tube.\n\n    float band = 1e5;\n    const float aNum = 1.;\n\n    \n    float ia = floor(p.z*3.*aNum);\n\n    float opz = mod(p.z + 1./aNum/3., 1./aNum);\n    \n    p.z = mod(p.z, 1./aNum/3.) - .5/aNum/3.;\n\tp = abs(p);\n    \n    // Bands, or sleeves.\n    band = max(tb - .0075, p.z - .06);\n    vec2 peg = vec2(tube(p.xz, .64, .0425), tube(p.yz, .64, .0425)); \n\n    \n    if(opz>2./aNum/3.){\n  \n        band = min(band, max(tube(p.xy, .6, rad2 + .015), p.z - .04));\n    \t//band = max(band, min(band + .005, -p.z + .015));\n        band = min(band, max(tube(p.xy, .6, rad2 + .025), p.z - .04/3.));\n    }\n    else {\n    \n        // Portals on alternate bands.\n        \n        float hole = min(peg.x, peg.y);\n        \n        // Octagonal portal flush. The rest are raised a little. No reason. Just a design choice.\n        #if TUBE_SHAPE == 3\n        band = min(band, min(max(peg.x, p.y - rad2 - .0075), max(peg.y, p.x - rad2 - .0075)));\n        #else\n        band = min(band, min(max(peg.x, p.y - rad2 - .02), max(peg.y, p.x - rad2 - .02)));\n        #endif\n        band = max(band, -(hole + .015));\n        \n        tb = max(tb, -(hole + .015));\n        \n                // Inner tube. Actually, just some spheres at the portal positions, but to the observer,\n        // it gives the impression of an inner tube.\n        innerTb = length(p) - rad2 + .01;\n        \n    }\n\n    \n    // Return the tube, bands, and inner tube objects.\n    return vec4(tb, band, innerTb, ia);\n    \n    \n}\n\n\n\n// I can thank Mattz for reminding me of this. You don't need to call all three decorated tubes,\n// then determine the minimum. You can determine the minimum main tube, then call the function\n// for the tube containing the more elaborate detailing that corresponds to it. And by that I\n// mean return the unique oriented point that corresponds to the nearest tube segment distance.\n//\nvec4 torTubeTest(vec3 p){\n    \n    vec2 v = vec2(length(p.xy) - .5, p.z);\n    \n    // Main tube distance squared. Note: If a + c < b + c, then a*a<b*b.\n    // Ie: we don't need to test length(v) - r, just dot(v, v);\n    return vec4(p, dot(v, v));\n}\n\nvec4 straightTubeTest(vec3 p){\n    \n    vec2 v = p.xy;\n    \n    // Main tube distance squared. Note: If a + c < b + c, then a*a<b*b.\n    // Ie: we don't need to test length(v) - r, just dot(v, v);\n    return vec4(p, dot(v, v));\n}\n\n\n/*\n\n\tThe Truchet pattern:\n\n\tA standard 3D Truchet tile consists of three toroids centered on three edges of a cube, \n    positioned to enter and exit six cube faces... Look one up on the internet, and that \n\tdiatribe will make more sense. :) The idea is to connect the tiles in a 3D grid, then \n\trandomly rotate each around one of the axes to produce an interesting spaghetti looking \n\tpattern.\n\n\tConstructing the individual tiles is as simple as breaking space into a cubic grid then\n\tpositioning three tori in each cell. If you can position, rotate and render a torus,\n\tthen it should be rudimentary.\n\n\tThis example uses an additional block consisting of a straight tube connecting two\n\topposite faces and two tori to connect the other four. That should be easy enough to\n\tconstruct too.\n\n*/\n\nfloat map(vec3 p)\n{\n \n    // Random ID for each grid cube.\n    float rnd = fract(sin(dot(floor(p + vec3(111, 73, 27)), vec3(7.63, 157.31, 113.97)))*43758.5453);\n    float rnd2 = fract(rnd*41739.7613 + .131);\n\n    // Partition space into a grid of unit cubes - centered at the origin and ranging from\n    // vec3(-.5, -.5, -.5) to vec3(-.5, -.5, -.5).\n    p = fract(p) - .5;\n      \n    // Use each cube's random ID to rotate it in such a way that another one of its faces is \n    // facing forward. In case you're not aware, the swizzling below is a cheap trick used to\n    // achieve this. By the way, there may be a faster way to write the conditionals - using \n    // ternary operators, or something to that effect, but I'm leaving it this way for now... \n    // However, if a GPU expert feels that it's unnecessarily slow, then feel free to let me \n    // know, and I'll change it.\n    if(rnd>.833) p = p.xzy;\n    else if(rnd>.666) p = p.yxz;\n    else if(rnd>.5) p = p.yzx;\n    else if(rnd>.333) p = p.zxy;\n    else if(rnd>.166) p = p.zyx;\n        \n    // I can thank Mattz for reminding me of this step. Each Truchet tile contains three decorated\n    // tubes. However, you only need to find the closest tube, \"not\" the closest decorated tube, which\n    // requires a lot more GPU power. Each of these return the closest point and the distance...\n    // Actually, the squared distance, which for comparisson purposes, is the same thing.\n    vec4 tb1, tb2, tb3;\n    tb1 = torTubeTest(vec3(p.xy + .5, p.z));\n    if(rnd2>.66){\n    \t\n    \ttb2 = torTubeTest(vec3(p.yz - .5, p.x));\n    \ttb3 = torTubeTest(vec3(p.xz - vec2(.5, -.5), p.y));\n    }\n    else {\n    \t\n    \ttb2 = torTubeTest(vec3(p.xy - .5, p.z));\n    \ttb3 = straightTubeTest(p);  \n    }\n     \n    // Sort the distances, then return the closest point.\n    p = tb1.w<tb2.w && tb1.w<tb3.w ? tb1.xyz : tb2.w<tb3.w ? tb2.xyz : tb3.xyz;\n \n    // Render the randomly aligned Truchet block. Ie, the three tori - plus bells and whistles.\n    // Each quarter torus consists of three separate objects: A white tube with some holes in it, \n    // some bracing (the colored sleeve looking things) and a colored inner tube. That's nine\n    // objects returned in all. If it were not for the need to sort objects and attain a segment\n    // identifier (tb.w), only a float would be necessary.\n    vec4 tb;\n    \n    if(rnd2<=.66 && tb3.w<tb1.w && tb3.w<tb2.w) tb = straightTube(p);\n    else tb = torTube(p);\n        \n\n    /// A unique angular segment identifier - Not used here.\n    //gID = tb.w;\n    \n     \n    // Each torus segment contains three individual objects. Here, we're finding the minimum in\n    // each category. We're keeping a global copy here that will be sorted for object identification\n    // outside the raymarching loop. The reason this step is necessary is because the line below\n    // finds the closest object, but doesn't tell us which object that is. That requires sorting,\n    // which is best done outside the loop, for speed reasons.\n    vObjID = tb.xyz;\n    \n    // Finding the minimum of the above to determine the overall minimum object in the scene.\n    return min(min(vObjID.x, vObjID.y), vObjID.z);\n    \n    \n}\n\n\n/*\n// Recreating part of the distance function to obtain the segment IDs, which in turn is used\n// to create the blink effect.\nfloat lightBlink(vec3 p, float gID){\n    \n    // Unique identifier for the cubic grid cell.\n    float rnd = fract(sin(dot(floor(p + vec3(111, 73, 27)), vec3(7.63, 157.31, 113.97)))*43758.5453);\n \n    // Reusing \"rnd\" to produce a new random number, then using that\n    // random number to create lights that blink at random intervals.\n    rnd = fract(rnd + gID*43758.54571);\n    \n    // Blink at random.\n    return smoothstep(0.33, .66, sin(rnd*6.283 + iTime*3.)*.5 + .5);\n\n    \n}\n*/\n\n\n// Standard raymarching algorithm.\nfloat trace(vec3 o, vec3 r){\n    \n    glow = 0.;\n    \n    // Total ray distance travelled, and nearest distance at the current ray position.\n    float t = 0., d, ad;\n    \n    for (int i = 0; i<128; i++) {\n        \n        // Surface distance.\n        d = map(o + r*t);\n        ad = abs(d);\n        \n        // Applying some glow. There are better ways to go about it, but this will do.\n        //if(ad<.25) glow += (.25 - ad)/(1. + d*8.);\n        //if(ad<.25) glow += (.25 - ad)/(.25 + ad*ad);\n        glow += 1./(1. + ad*ad*8.);\n        //if(vObjID.z<vObjID.x && vObjID.z<vObjID.y && ad<.25) glow += (.25 - ad))/(1. + t);\n        \n        // If the ray position is within the surface threshold (\"abs\" means either side of the \n        // surface), or if we've traversed beyond the maximum, exit the loop.\n        if(ad<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        // Standard jump.\n        t += d; \n        \n        // Shortening the ray jump right near the camera to alleviated near-camera artifacts.\n        //t += t<.125 ? d*.7 : d; \n    }\n    \n    // Clamp the total distance to \"FAR.\" It can sometimes get rid of far surface artifacts.\n    return min(t, FAR);\n}\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat shadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .001*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .2); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n    }\n\n    // I sometimes add a constant to the final shade value, which lightens the shadow a bit. It's a preference \n    // thing. Really dark shadows look too brutal to me. Sometimes, I'll also add AO, just for kicks. :)\n    return min(max(shade, 0.) + .0, 1.); \n    \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1.25, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = .01 + float(i)*.5/4.;        \n        float dd = map(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);   \n    \n}\n\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 nrm(vec3 p, inout float edge, inout float crv, float t) { \n\t\n    // It's worth looking into using a fixed epsilon versus using an epsilon value that\n    // varies with resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    vec2 e = vec2(1./mix(400., iResolution.y, .5)*(1. + t*.5), 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e Gospels.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.002, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Ray origin, or camera - Moving along the Z-axis.\n    float tm = iTime;\n    #ifdef CAMERA_WEAVE\n    tm *= .75;\n    #endif\n    \n    vec3 o = vec3(0, 0, tm); \n    // Light. Situated near the camera whilst moving along with it.\n\t//vec3 lp = vec3(-1, 3, -.25) + o;\n    vec3 lp = o + vec3(-1, 3, -1);\n    \n    // Cheap, last minute camera weave. Suggested by ExNihilo. To implement this properly, I need to add\n\t// add a few lines to set up a proper \"too\" and \"from\" camera... add a camera path function...\n    // maybe later. :)\n    #ifdef CAMERA_WEAVE\n    o.x += sin(tm * 3.14159265/6. + 1.5707963);\n    #endif\n    \n    // Unit ray vector.\n    //vec3 r = normalize(vec3(uv, 1));\n    // Slight bulbous scene warp.\n    vec3 r = normalize(vec3(uv, 1.15));\n    r = normalize(vec3(r.xy, r.z - length(r.xy)*.15));\n    \n    // Rotating \"r\" back and forth along various axes for some cheap camera movement. \n    #ifdef CAMERA_WEAVE\n    r.xz *= rot2(-sin(tm/2. - 1.5707963) * 0.6);\n    r.xy *= rot2(-sin(tm/2. - 1.5707963) * 0.4);\n    //r.yz *= rot2(-sin(tm/2.) * 0.2);\n    #else\n    r.xz *= rot2(sin(tm/2.) * 0.4);\n    r.xy *= rot2(cos(tm/2.) * 0.2);\n    #endif\n    \n    // Trace out the scene.\n    float t = trace(o, r);\n     \n    // Determining the object ID. Sorting the three different objects outside the loop\n    // is a little less readable, but usually faster. See the distance function.\n    //\n    // Scene object ID: Main tube, colored inner tube or band.\n    float objID = (vObjID.x<vObjID.y && vObjID.x<vObjID.z) ? 0. : (vObjID.y<vObjID.z) ? 1. : 2.;\n\n    // Segment ID: Sorting the segments to determine the unique ID. This ID is fed\n    // into a function to give various effects. Not used here.\n    //float svGID = gID;\n \n\t// Initiate the scene color to zero.\n    vec3 sc = vec3(0);\n    \n    \n    // An object in the scene has been hit, so light it.\n    if(t<FAR){\n        \n        // Hit position.\n        vec3 sp = o + r*t;\n        \n        // Normal, plus edges and curvature. The latter isn't used.\n        float edge = 0., crv = 1.;\n        vec3 sn = nrm(sp, edge, crv, t);\n\n        \n        // Producing a gradient color based on position. Made up on the spot.\n        vec3 oCol = vec3(1);\n        vec3 bCol = mix(vec3(1, .1, .3).zyx, vec3(1, .5, .1).zyx, dot(sin(sp*8. - cos(sp.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        //bCol = bCol.zyx; //bCol.yzx; // Other colors, if you prefer.\n\n\n        \n        // Color the individual objects, based on object ID.\n        if(objID<.5)oCol = mix(bCol, vec3(1), .97);\n        else if(objID>1.5) oCol = mix(bCol, vec3(1), .05) + bCol*2.;\n        else oCol = oCol = mix(bCol, vec3(1.35), .97)*vec3(1.1, 1, .9);\n\n        // A bit of subtle texture applied to the object.\n        vec3 tx = tex3D(iChannel0, sp*2., sn);\n        tx = smoothstep(.0, .5, tx)*2.;\n        //\n        if(objID<1.5) oCol *= tx;\n        else oCol *= mix(vec3(1), tx, .5);\n        \n        \n        // Ambient occlusion and shadows.\n        float ao = cAO(sp, sn);\n        float sh = shadow(sp + sn*.002, lp, 16., t); \n        \n\n        // Point light direction vector.\n        vec3 ld = lp - sp;\n        float dist = max(length(ld), 0.001); // Distance.\n        ld /= dist; // Using the distance to nomalize the point light direction vector.\n        \n\n        // Attenuation - based on light to surface distance.\n        float atten = 3.5/(1. + dist*0.05 + dist*dist*0.05);\n        \n        // Diffuse light.\n        float diff = max(dot(ld, sn), 0.);\n        if(objID<1.5) diff = pow(diff, 4.)*2.;\n        float spec = pow(max(dot( reflect(ld, sn), r), 0.0 ), 32.0);\n        //float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        \n       \t\n        \n        // Combining the above terms to produce the final color.\n        sc = oCol*(diff + ao*.2) + mix(bCol.zyx, vec3(1, .7, .3), .5)*spec*4.;\n        \n        // Fake caustic lighting... Very fake. :)\n        sc += .015/max(abs(.05 - map(sp*1.5 + sin(iTime/6.))), .01)*oCol*mix(bCol, vec3(1, .8, .5), .35);\n        \n        // Adding a bit of glow. It was tempting to get my money's worth, but I kept it subtle. :)\n        if(objID<1.5) sc += bCol*glow*.025;\n        else sc += bCol*glow*1.5;\n        \n        // Applying the dark edges, attenuation, shadows and ambient occlusion.\n        sc *= (1. - edge*.7);\n        sc *= atten*(sh + ao*.25)*ao;\n        \n    }\n    \n    \n    \n    // Applying some basic camera distance fog. Not to be confused with the light\n    // to surface attenuation.\n    float fog = 1./(1. + t*.125 + t*t*.05);\n    sc = mix(vec3(0), sc, fog);//\n    //sc = mix(sc, vec3(0), smoothstep(0.0, .2, t/FAR));\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sc *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n    // Colored variation.\n    //sc = mix(pow(min(vec3(1.5, 1, 1).zyx*sc, 1.), vec3(1, 3, 16).zyx), sc, \n             //pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.75 + .25);\n    \n    \n\tfragColor = vec4(sqrt(max(sc, 0.)), 1);\n}"
    },        
    "god_face": {
      "name": "God Face",
      "category": "SHADER PRESETS",
      "code": "// License CC0: Face in the clouds\n// Symmetry around y-axis creates illusion of a face\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define TTIME       (TIME*TAU)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define DOT2(x)     dot(x, x)\n#define RESOLUTION  iResolution\n\nconst mat2 frot = ROT(PI/3.33);\n\nvec2 g_vx = vec2(0.0, 0.0);\nvec2 g_vy = vec2(3.2, 1.3);\nvec2 g_wx = vec2(1.7, 9.2);\nvec2 g_wy = vec2(8.3, 2.8);\n\n// HSV to RGB\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f, b = 0.03f, c = 2.43f, d = 0.59f, e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) { sz = sz.yx; } else { p = p.yx; }\n  vec2 sz2 = sz*sz;\n  float d = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r = sqrt(sz2.x+d*d);\n  float b = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b)) : length(p-vec2(-d,0.0))-r;\n}\n\nfloat pabs(float a, float k) { return -pmin(a, -a, k); }\n\nfloat noise(vec2 p) {\n  float a = sin(p.x), b = sin(p.y), c = 0.5 + 0.5*cos(p.x + p.y);\n  return mix(a, b, c);\n}\n\nfloat fbm(vec2 p) {    \n  float f = 0.0, a = 1.0, s = 0.0, m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); p = frot*p*m;\n    m += 0.01; s += a; a *= 0.5;\n  }\n  return f/s;\n}\n\nvec2 df(vec2 p) {\n  vec2 p0 = p; p0.x = abs(p0.x); p0 -= vec2(0.75, 0.4); p0 *= ROT(PI/9.0);\n  float d0 = vesica(p0, vec2(0.45, 0.2)), g0 = length(p0);\n  return vec2(d0, g0);\n}\n\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\n  float d = df(p).x-0.1; p.x = -pabs(p.x, 0.125);\n  v = vec2(fbm(p + g_vx), fbm(p + g_vy));\n  w = vec2(fbm(p + 3.0*v + g_wx), fbm(p + 3.0*v + g_wy));\n  float h = fbm(p + 2.25*w);\n  float aa = 0.2; h *= mix(1.0, 0.05, smoothstep(aa, -aa, d));\n  return h*smoothstep(2.5, 0.15, abs(p.x+0.5*p.y));\n}\n\nvec3 normal(vec2 p) {\n  vec2 v, w; float eps = 2.0/RESOLUTION.y; vec2 e = vec2(eps, 0);\n  vec3 n;\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\n  return normalize(n);\n}\n\nvec3 smear(vec2 p, vec2 q) {\n  float aa = 2.0/RESOLUTION.y;\n  g_vx *= ROT(TTIME/1000.0); g_vy *= ROT(TTIME/900.0);\n  g_wx *= ROT(TTIME/800.0); g_wy *= ROT(TTIME/700.0);\n\n  vec2 v, w; vec2 d2 = df(p); float d = abs(d2.x) - 2.0*aa; float g = d2.y;\n  float h = warp(p, v, w); vec3 n = normal(p);\n\n  vec3 ld1 = normalize(vec3(0.5, 0.2, 0.4)), ld2 = normalize(vec3(-0.5, 0.2, -0.4));\n  vec3 lcol1 = HSV2RGB(vec3(0.9, 0.333, 1.0)), lcol2 = HSV2RGB(vec3(0.6, 0.125, 2.0));\n  vec3 acol = HSV2RGB(vec3(0.6, 0.0, 0.3));\n\n  float dif1 = pow(max(dot(ld1, n), .0), 1.0), dif2 = pow(max(dot(ld2, n), .0), 2.0);\n\n  const vec3 col11 = HSV2RGB(vec3(0.9, 0.9, 0.5)), col21 = HSV2RGB(vec3(0.4, 0.9, 0.5));\n  const vec3 col12 = HSV2RGB(vec3(0.6, 0.9, 1.5)), col22 = HSV2RGB(vec3(0.0, 0.9, 1.5));\n\n  vec3 col1 = mix(col11, col12, q.x), col2 = mix(col21, col22, q.y);\n  \n  vec3 col = vec3(0.0); float lv = length(v), lw = length(w);\n  col += lv*col1*dif1*lcol1; col += lw*col2*dif1*lcol1;\n  col += lv*col1*dif2*lcol2; col += lw*col2*dif2*lcol2;\n  col += lv*col1*acol; col += lw*col2*acol;\n  col *= smoothstep(0.0, 1., (h*h+0.05+0.75*0.125*(1.0+p.y)));\n  col *= smoothstep(2.0, 8.0, TIME-length(p));\n  col += mix(5.0, 1.0, 0.5+0.5*sin(TTIME/8.0))*HSV2RGB(vec3(0.6, 0.8, 1.0))*exp(-40.0*g);\n  col *= smoothstep(0.0, 4.0, TIME);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy; vec2 p = -1. + 2. * q; p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = smear(p, q); col = aces_approx(col); col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}"
    },
    "MandelbulbX": {
      "name": "MandelbulbX",
      "category": "FRACTAL PRESETS",
      "code": "#define BOUNDING_RADIUS 1.1\n\n#define COLOR1 vec3(1.0, 0.3, 0.0)\n#define COLOR2 vec3(0.0, 0.7, 1.0)\n#define BACKGROUND vec3(0.9, 0.8, 0.8)\n\n#define ir3 0.57735\n\nfloat mandelbulb(vec3 pos){\n    vec3 w = pos;\n    float dr = 1.0,r;\n    vec3 p,p2,p4;\n    float k1,k2,k3,k4,k5;\n\n    for (int i = 0; i < 10; i++){\n        r = dot(w, w);\n        if (r > 4.0) break;\n        dr =  pow(r, 3.5)*8.0*dr + 1.0;\n\n        p = w;\n        p2 = w * w;\n        p4 = p2 * p2;\n\n        k3 = p2.x + p2.z;\n        k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        k1 = dot(p4, vec3(1)) - 6.0 * dot(p2, vec3(p2.y, p2.z, -p2.x / 3.0));\n        k4 = dot(p2, vec3(1, -1, 1));\n        k5 = 8.0*p.y*k4*k1*k2;\n\n        w = pos + vec3(8.0*k5*p.x*p.z*(p2.x-p2.z)*(p4.x-6.0*p2.x*p2.z+p4.z),\n                       -16.0*p2.y*k3*k4*k4 + k1*k1,\n                       -k5*(p4.x*p4.x - 28.0*p4.x*p2.x*p2.z + \n                            70.0*p4.x*p4.z - 28.0*p2.x*p2.z*p4.z + p4.z*p4.z));\n    }\n    return log(r)*sqrt(r)/dr;\n}\n\nfloat dist(vec3 p) {\n    return 0.385*mandelbulb(p);\n}\n\nbool bounding(in vec3 ro, in vec3 rd){\n    float b = dot(rd,ro);\n    return dot(ro,ro) - b*b < BOUNDING_RADIUS * BOUNDING_RADIUS;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n    if (bounding(ro, rd)){\n        float t = 0.72, d;\n        for (int i = 0; i < 96; i++){\n            d = dist(ro + rd * t);\n            t += d;\n\n            if (d < 0.002) return vec2(t, d);\n            if (d > 0.4) return vec2(-1.0);\n        }\n    }\n\n    return vec2(-1.0);\n}\n\nvec3 normal(vec3 p){\n    const float eps = 0.005;\n    return normalize(vec3(dist(p+vec3(eps,0,0))-dist(p-vec3(eps,0,0)),\n                          dist(p+vec3(0,eps,0))-dist(p-vec3(0,eps,0)),\n                          dist(p+vec3(0,0,eps))-dist(p-vec3(0,0,eps))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float theta = iTime * 0.2;\n    mat2 rot = mat2(+cos(theta), -sin(theta),\n                    +sin(theta), +cos(theta));\n    mat2 rrot = mat2(+cos(theta), +sin(theta),\n                     -sin(theta), +cos(theta));\n    vec2 rxz = vec2(0.0, -1.8) * rot;\n    vec3 ro = vec3(rxz.x, sin(theta*1.61)*0.1, rxz.y);\n    //coordinates of pixel\n    vec2 uv = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n\n\n    vec3 rd = normalize(vec3(uv, 1.1));\n    rd.xz *= rot;\n\n    vec2 res = march(ro, rd);\n\n    if (res.x > 0.0){\n        vec3 end = ro + rd * res.x;\n\n        vec3 norm = normal(end-rd*0.001);\n\n        float ao = clamp((dist(end + norm * 0.02) - res.y) / 0.02, 0.0, 1.0);\n        norm.xz *= rrot;\n\n        float m = clamp(dot(end, end), 0.0, BOUNDING_RADIUS) / BOUNDING_RADIUS;\n        vec3 col = mix(COLOR1, COLOR2, m*m*m);\n\n        float d = max(dot(norm, vec3(-ir3)), 0.0);\n        vec3 light = col * ao + 0.2 * d + 0.4 * d*d*d*d*d*d*d*d;\n\n        fragColor = vec4(light, 1.0);\n    } else {\n        fragColor = vec4(BACKGROUND - length(uv) / 4.0, 1.0);\n    }\n}"
    },
    "mars": {
      "name": "Mars",
      "category": "SHADER PRESETS",
      "code": "// Xyptonjtroz by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/4ts3z2\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define ITR 100\n#define FAR 30.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nfloat height(in vec2 p) { p *= 0.2; return sin(p.y)*0.4 + sin(p.x)*0.4; }\n\nfloat smin( float a, float b) { float h = clamp(0.5 + 0.5*(b-a)/0.7, 0.0, 1.0); return mix(b, a, h) - 0.7*h*(1.0-h); }\n\nvec2 nmzHash22(vec2 q) {\n    uvec2 p = uvec2(ivec2(q)); p = p*uvec2(3266489917U, 668265263U) + p.yx;\n    p = p*(p.yx^(p >> 15U)); return vec2(p^(p >> 16U))*(1.0/vec2(0xffffffffU));\n}\n\nfloat vine(vec3 p, in float c, in float h) {\n    p.y += sin(p.z*0.2625)*2.5; p.x += cos(p.z*0.1575)*3.;\n    vec2 q = vec2(mod(p.x, c)-c/2., p.y);\n    return length(q) - h -sin(p.z*2.+sin(p.x*7.)*0.5+time*0.5)*0.13;\n}\n\nfloat map(vec3 p) {\n    p.y += height(p.zx); vec3 bp = p; vec2 hs = nmzHash22(floor(p.zx/4.)); p.zx = mod(p.zx,4.)-2.;\n    float d = p.y+0.5; p.y -= hs.x*0.4-0.15; p.zx += hs*1.3; d = smin(d, length(p)-hs.x*0.4);\n    d = smin(d, vine(bp+vec3(1.8,0.,0),15.,.8) ); d = smin(d, vine(bp.zyx+vec3(0.,0,17.),20.,0.75) );\n    return d*1.1;\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n\tfloat precis = 0.002, h=precis*2.0, d = 0.;\n    for( int i=0; i<ITR; i++ ) { if( abs(h)<precis || d>FAR ) break; d += h; h = map(ro+rd*d); }\n\treturn d;\n}\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\nfloat triNoise3d(in vec3 p, in float spd) {\n    float z=1.4, rz = 0.; vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ ) {\n        vec3 dg = tri3(bp*2.); p += (dg+time*spd); bp *= 1.8; z *= 1.5; p *= 1.2;\n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z; bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat fogmap(in vec3 p, in float d) { p.x += time*1.5; p.z += sin(p.x*.5); return triNoise3d(p*2.2/(d+20.),0.2)*(1.-smoothstep(0.,.7,p.y)); }\n\nvec3 fog(in vec3 col, in vec3 ro, in vec3 rd, in float mt) {\n    float d = .5;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ro + rd*d; float rz = fogmap(pos, d);\n\t\tfloat grd = clamp((rz - fogmap(pos+.8-float(i)*0.1,d))*3., 0.1, 1. );\n        vec3 col2 = (vec3(.1,0.8,.5)*.5 + .5*vec3(.5, .8, 1.)*(1.7-grd))*0.55;\n        col = mix(col,col2,clamp(rz*smoothstep(d-0.4,d+2.+d*.75,mt),0.,1.) );\n        d *= 1.5+0.3; if (d>mt)break;\n    }\n    return col;\n}\n\nvec3 normal(in vec3 p) {  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat bnoise(in vec3 p) {\n    float n = sin(triNoise3d(p*.3,0.0)*11.)*0.6+0.4;\n    n += sin(triNoise3d(p*1.,0.05)*40.)*0.1+0.9;\n    return (n*n)*0.003;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds) {\n    vec2 e = vec2(.005,0); float n0 = bnoise(p);\n    vec3 d = vec3(bnoise(p+e.xyy)-n0, bnoise(p+e.yxy)-n0, bnoise(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*2.5/sqrt(ds));\n    return n;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0, t = mint;\n    for( int i=0; i<10; i++ ) {\n\t\tfloat h = map(ro + rd*t); res = min( res, 4.*h/t );\n        t += clamp( h, 0.05, .5 );\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat curv(in vec3 p, in float w) {\n    vec2 e = vec2(-1., 1.)*w;   \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy), t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    return .125/(e.x*e.x) *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5; vec2 q = fragCoord.xy/iResolution.xy;\n\tp.x*=iResolution.x/iResolution.y; vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.07):mo; mo.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 ro = vec3(smoothstep(0.,1.,tri(time*.45)*2.)*0.1, smoothstep(0.,1.,tri(time*0.9)*2.)*0.07, -time*0.6);\n    ro.y -= height(ro.zx)+0.05; mo.x += smoothstep(0.6,1.,sin(time*.6)*0.5+0.5)-1.5;\n    vec3 eyedir = normalize(vec3(cos(mo.x),mo.y*2.-0.2+sin(time*0.45*1.57)*0.1,sin(mo.x)));\n    vec3 rightdir = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 updir = normalize(cross(rightdir,eyedir));\n\tvec3 rd=normalize((p.x*rightdir+p.y*updir)*1.+eyedir);\n\t\n    vec3 ligt = normalize( vec3(.5, .05, -.2) ), ligt2 = normalize( vec3(.5, -.1, -.2) );\n    \n\tfloat rz = march(ro,rd);\n\t\n    vec3 fogb = mix(vec3(.7,.8,.8)*0.3, vec3(1.,1.,.77)*.95, pow(dot(rd,ligt2)+1.2, 2.5)*.25);\n    fogb *= clamp(rd.y*.5+.6, 0., 1.); vec3 col = fogb;\n    \n    if ( rz < FAR ) {\n        vec3 pos = ro+rz*rd; vec3 nor= normal( pos ); float d = distance(pos,ro);\n        nor = bump(pos,nor,d); float crv = clamp(curv(pos, .4),.0,10.);\n        float shd = shadow(pos,ligt,0.1,3.); float dif = clamp( dot( nor, ligt ), 0.0, 1.0 )*shd;\n        float spe = pow(clamp( dot( reflect(rd,nor), ligt ), 0.0, 1.0 ),50.)*shd;\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 1.5 );\n        vec3 brdf = vec3(0.10,0.11,0.13); brdf += 1.5*dif*vec3(1.00,0.90,0.7);\n        col = mix(vec3(0.1,0.2,1),vec3(.3,.5,1),pos.y*.5)*0.2+.1;\n        col *= (sin(bnoise(pos)*900.)*0.2+0.8);\n        col = col*brdf + col*spe*.5 + fre*vec3(.7,1.,0.2)*.3*crv;\n    }\n    \n    col = mix(col, fogb, smoothstep(FAR-7.,FAR,rz));\n    col = fog(col, ro, rd, rz);\n    col = pow(col,vec3(0.8));\n    col *= 1.-smoothstep(0.1,2.,length(p));\n    \n\tfragColor = vec4( col, 1.0 );\n}"
    },
    "gpu_pipeline": {
      "name": "GPU Pipeline Demo",
      "category": "SHADER PRESETS",
      "code": "// GPU Pipeline Visualization - Rotating 3D Boxes + Circles\n// Demonstrates vertex processing, perspective projection, and rasterization\n\n#define LINEAR_ROTATION\n\n#define WEIGHT (3.0 / iResolution.x)\nconst vec3 RED = vec3(1.0,0.0,0.0);\nconst vec3 GREEN = vec3(0.0,1.0,0.0);\nconst vec3 BLUE = vec3(0.0,0.8,1.0);\nconst vec3 WHITE = vec3(1.0,1.0,0.97);\nconst vec3 YELLOW = vec3(1.0,1.0,0.0);\n\n// rasterize functions\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\nfloat circle(vec2 p, vec2 c, float r, float w) {\n    float dist = abs(length(p - c)) + r;\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\n\n// matrices\nmat4 getRotMatrix(vec3 a) {\n    vec3 s = sin(a);\n    vec3 c = cos(a);    \n    mat4 ret;\n    ret[0] = vec4(c.y*c.z,c.y*s.z,-s.y,0.0);\n    ret[1] = vec4(s.x*s.y*c.z-c.x*s.z,s.x*s.y*s.z+c.x*c.z,s.x*c.y,0.0);\n    ret[2] = vec4(c.x*s.y*c.z+s.x*s.z, c.x*s.y*s.z-s.x*c.z,   c.x*c.y,0.0);    \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\nmat4 getPosMatrix(vec3 p) {   \n    mat4 ret;\n    ret[0] = vec4(1.0,0.0,0.0,p.x);\n    ret[1] = vec4(0.0,1.0,0.0,p.y);\n    ret[2] = vec4(0.0,0.0,1.0,p.z);   \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\n\n// utils\nvec3 mix3(vec3 a, vec3 b, vec3 c, float t) {\n    if(t>0.5) return mix(b,c,t*2.0-1.0);\n    else return mix(a,b,t*2.0);\n}\nvec3 fragment(vec3 p) {\n    float t = sin(p.x*0.8+iTime*0.5)*0.5+0.5;\n    float fog = min(pow(p.z,3.0)*400.0,1.0);\n    return mix3(RED,GREEN,BLUE,t) * fog;\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float line_width = 0.4;\n    float time = iTime * 0.31415;\n    vec3 c = vec3(mix(vec3(0.19,0.13,0.1),vec3(1.0), 0.5*pow(length(uv)*0.5,2.0)));\n    mat4 cam = getPosMatrix(vec3(0.0,0.0,10.0));\n    \n#ifdef LINEAR_ROTATION\n    mat4 rot = getRotMatrix(vec3(time,time*0.86,time*0.473));\n#else\n    float p = 0.08;\n    mat4 rot = getRotMatrix(vec3(time\t\t+sin(time*30.0)*p,\n                                 time*0.860\t+sin(time*20.0)*p*1.24,\n                                 time*0.473\t+sin(time*10.0)*p));\n#endif\n    \n    vec3 instances[18];\n    instances[0] = vec3( 0.0, 0.0,-1.0);\n    instances[1] = vec3(-1.0, 0.0,-1.0);\n    instances[2] = vec3( 1.0, 0.0,-1.0);\n    instances[3] = vec3( 0.0, 1.0,-1.0);\n    instances[4] = vec3( 0.0,-1.0,-1.0);    \n    instances[5] = vec3(-1.0, 0.0, 0.0);\n    instances[6] = vec3( 1.0, 0.0, 0.0);\n    instances[7] = vec3( 0.0, 1.0, 0.0);\n    instances[8] = vec3( 0.0,-1.0, 0.0);        \n    instances[9] = vec3(-1.0,-1.0, 0.0);\n    instances[10] = vec3( 1.0, 1.0, 0.0);\n    instances[11] = vec3(-1.0, 1.0, 0.0);\n    instances[12] = vec3( 1.0,-1.0, 0.0);    \n    instances[13] = vec3( 0.0, 0.0, 1.0);\n    instances[14] = vec3(-1.0, 0.0, 1.0);\n    instances[15] = vec3( 1.0, 0.0, 1.0);\n    instances[16] = vec3( 0.0, 1.0, 1.0);\n    instances[17] = vec3( 0.0,-1.0, 1.0);\n    \n    // box pipeline\n    for(int dip = 0; dip < 18; dip++) {\n        \n        // input assembly\n        vec3 vert[8];\n        vert[0] = vec3(-1.0,-1.0, 1.0);\n        vert[1] = vec3(-1.0, 1.0, 1.0);    \n        vert[2] = vec3( 1.0, 1.0, 1.0);    \n        vert[3] = vec3( 1.0,-1.0, 1.0);\n        vert[4] = vec3(-1.0,-1.0,-1.0);\n        vert[5] = vec3(-1.0, 1.0,-1.0);    \n        vert[6] = vec3( 1.0, 1.0,-1.0);    \n        vert[7] = vec3( 1.0,-1.0,-1.0);\n\n        // vertex processing        \n        mat4 pos = getPosMatrix(instances[dip] * 4.0);\n        mat4 mat = pos * rot * cam;\n\n        for(int i = 0; i < 8; i++) {\n\n            // transform\n            vert[i] = (vec4(vert[i],1.0) * mat).xyz;\n\n            // perspective\n            vert[i].z = 1.0 / vert[i].z;\n            vert[i].xy *= vert[i].z;\n        }    \n\n        // primitive assembly and rasterize\n        float i;\n        i  = line(uv,vert[0].xy,vert[1].xy,line_width);\n        i += line(uv,vert[1].xy,vert[2].xy,line_width);\n        i += line(uv,vert[2].xy,vert[3].xy,line_width);\n        i += line(uv,vert[3].xy,vert[0].xy,line_width);\n        i += line(uv,vert[4].xy,vert[5].xy,line_width);\n        i += line(uv,vert[5].xy,vert[6].xy,line_width);\n        i += line(uv,vert[6].xy,vert[7].xy,line_width);\n        i += line(uv,vert[7].xy,vert[4].xy,line_width);\n        i += line(uv,vert[0].xy,vert[4].xy,line_width);\n        i += line(uv,vert[1].xy,vert[5].xy,line_width);\n        i += line(uv,vert[2].xy,vert[6].xy,line_width);\n        i += line(uv,vert[3].xy,vert[7].xy,line_width);\n        c += fragment(vert[0]) * min(i,1.0);\n    }\n        \n    instances[0] = vec3(-1.0, 1.0,-1.0);\n    instances[1] = vec3( 1.0, 1.0,-1.0);\n    instances[2] = vec3(-1.0,-1.0,-1.0);\n    instances[3] = vec3( 1.0,-1.0,-1.0);\n    instances[4] = vec3(-1.0, 1.0, 1.0);\n    instances[5] = vec3( 1.0, 1.0, 1.0);\n    instances[6] = vec3(-1.0,-1.0, 1.0);\n    instances[7] = vec3( 1.0,-1.0, 1.0);\n    \n    // circle pipeline\n    for(int dip = 0; dip < 8; dip++) {\n        \n        // input assembly\n        vec3 vert = vec3(0.0);\n\n        // vertex processing\n        mat4 pos = getPosMatrix(instances[dip] * 4.0);\n        mat4 mat = pos * rot * cam;\n\n        // transform\n        vert = (vec4(vert,1.0) * mat).xyz;\n\n        // perspective\n        vert.z = 1.0 / vert.z;\n        vert.xy *= vert.z;\n\n        // rasterize\n        c += fragment(vert) * circle(uv,vert.xy,-vert.z,line_width);\n    }\n    \n    // fragment\n\tfragColor = vec4(c,1.0);\n}"
    },
    "mandelbulb_power8": {
      "name": "Mandelbulb Power 8",
      "category": "FRACTAL SHADERS",
      "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// This is the code for this video from 2009: https://www.youtube.com/watch?v=iWr5kSZQ7jk\n\n\n// https://iquilezles.org/articles/intersectors\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n    \n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\nfloat map( in vec3 p, in vec3 c, out vec4 resColor )\n{\n    vec3 z = p;\n    float m = dot(z,z);\n\n    vec4 trap = vec4(abs(z),m);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<4; i++ )\n    {\n        // size of the derivative of z (comp through the chain rule)\n        // dz = 8*z^7*dz\n\t\tdz = 8.0*pow(m,3.5)*dz;\n        \n        // z = z^8+z\n        float r = length(z);\n        float b = 8.0*acos( clamp(z.y/r, -1.0, 1.0));\n        float a = 8.0*atan( z.x, z.z );\n        z = c + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n        \n        // orbit trapping\n        trap = min( trap, vec4(abs(z),m) );\n\n        m = dot(z,z);\n\t\tif( m > 2.0 )\n            break;\n    }\n\n    resColor = trap;\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, out vec4 rescol, float fov, vec3 c )\n{\n    float res = -1.0;\n\n    // bounding volume\n    vec2 dis = isphere( vec4( 0.0, 0.0, 0.0, 1.25 ), ro, rd );\n    if( dis.y<0.0 )\n        return -1.0;\n    dis.x = max( dis.x, 0.0 );\n\n\tvec4 trap;\n\n    // raymarch\n\tfloat fovfactor = 1.0/sqrt(1.0+fov*fov);\n\tfloat t = dis.x;\n\tfor( int i=0; i<256; i++  )\n    { \n        vec3 p = ro + rd*t;\n\n        float surface = clamp( 0.001*t*fovfactor, 0.0001, 0.1 );\n\n\t\tfloat dt = map( p, c, trap );\n\t\tif( t>dis.y || dt<surface ) break;\n\n        t += min(dt,0.05);\n    }\n    \n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k, vec3 c )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<150; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, c, kk);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.001, 0.05 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float t, in float fovfactor, vec3 c )\n{\n    vec4 tmp;\n    float surface = clamp( 0.0005*t*fovfactor, 0.0001, 0.1 );\n    vec2 eps = vec2( surface, 0.0 );\n\treturn normalize( vec3(\n           map(pos+eps.xyy,c,tmp) - map(pos-eps.xyy,c,tmp),\n           map(pos+eps.yxy,c,tmp) - map(pos-eps.yxy,c,tmp),\n           map(pos+eps.yyx,c,tmp) - map(pos-eps.yyx,c,tmp) ) );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    float time = iTime*.15;\n\n\tvec3 light1 = vec3(  0.577, 0.577, -0.577 );\n\tvec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\n\n\tfloat r = 1.3+0.1*cos(.29*time);\n\tvec3  ro = vec3( r*cos(.33*time), 0.8*r*sin(.37*time), r*sin(.31*time) );\n\tvec3  ta = vec3(0.0,0.1,0.0);\n\tfloat cr = 0.5*cos(0.1*time);\n\n\tfloat fov = 1.5;\n    vec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( p.x*cu + p.y*cv + fov*cw );\n\n\n\tvec3 cc = vec3( 0.9*cos(3.9+1.2*time)-.3, 0.8*cos(2.5+1.1*time), 0.8*cos(3.4+1.3*time) );\n\tif( length(cc)<0.50 ) cc=0.50*normalize(cc);\n\tif( length(cc)>0.95 ) cc=0.95*normalize(cc);\n\n\tvec3 col;\n\tvec4 tra;\n    float t = raycast( ro, rd, tra, fov, cc );\n    if( t<0.0 )\n    {\n     \tcol = 1.3*vec3(0.8,.95,1.0)*(0.7+0.3*rd.y);\n\t\tcol += vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n\telse\n\t{\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, fov, cc );\n        vec3 hal = normalize( light1-rd);\n        vec3 ref = reflect( rd, nor );\n        \n        col = vec3(1.0,1.0,1.0)*0.3;\n        col = mix( col, vec3(0.7,0.3,0.3), sqrt(tra.x) );\n\t\tcol = mix( col, vec3(1.0,0.5,0.2), sqrt(tra.y) );\n\t\tcol = mix( col, vec3(1.0,1.0,1.0), tra.z );\n        col *= 0.4;\n                \n\t\tfloat dif1 = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 );\n        float occ = clamp(1.2*tra.w-0.6,0.0,1.0);\n        float sha = softshadow( pos,light1, 0.0001, 32.0, cc );\n        float fre = 0.04 + 0.96*pow( clamp(1.0-dot(-rd,nor),0.0,1.0), 5.0 );\n        float spe = pow( clamp(dot(nor,hal),0.0,1.0), 12.0 ) * dif1 * fre*8.0;\n        \n\t\tvec3 lin  = 1.0*vec3(0.15,0.20,0.23)*(0.6+0.4*nor.y)*(0.1+0.9*occ);\n\t\t     lin += 4.0*vec3(1.00,0.90,0.60)*dif1*sha;\n\t\t     lin += 4.0*vec3(0.14,0.14,0.14)*dif2*occ;\n             lin += 2.0*vec3(1.00,1.00,1.00)*spe*sha * occ;\n             lin += 0.3*vec3(0.20,0.30,0.40)*(0.02+0.98*occ);\n\t\tcol *= lin;\n        col += spe*1.0*occ*sha;\n\t}\n\n\tcol = sqrt( col );\n\n\tfragColor = vec4( col, 1.0 );\n}"
    },
          
    "vcv_rack": {
      "name": "VcV Rack",
      "category": "SHADER PRESETS",
      "code": "// VcV Rack - Modular Synth Visualizer\n// Procedural 3D modular synthesizer rack with animated knobs, faders, and LEDs\n\n#define lofi(i,j) (floor((i)/(j))*(j))\n#define lofir(i,j) (round((i)/(j))*(j))\n\nconst float PI=acos(-1.);\nconst float TAU=PI*2.;\n\nmat2 r2d(float t){\n  float c=cos(t),s=sin(t);\n  return mat2(c,s,-s,c);\n}\n\nmat3 orthbas(vec3 z){\n  z=normalize(z);\n  vec3 up=abs(z.y)>.999?vec3(0,0,1):vec3(0,1,0);\n  vec3 x=normalize(cross(up,z));\n  return mat3(x,cross(z,x),z);\n}\n\nuvec3 pcg3d(uvec3 s){\n  s=s*1145141919u+1919810u;\n  s.x+=s.y*s.z;\n  s.y+=s.z*s.x;\n  s.z+=s.x*s.y;\n  s^=s>>16;\n  s.x+=s.y*s.z;\n  s.y+=s.z*s.x;\n  s.z+=s.x*s.y;\n  return s;\n}\n\nvec3 pcg3df(vec3 s){\n  uvec3 r=pcg3d(floatBitsToUint(s));\n  return vec3(r)/float(0xffffffffu);\n}\n\nstruct Grid{\n  vec3 s;\n  vec3 c;\n  vec3 h;\n  int i;\n  float d;\n};\n\nGrid dogrid(vec3 ro,vec3 rd){\n  Grid r;\n  r.s=vec3(2,2,100);\n  for(int i=0;i<3;i++){\n    r.c=(floor(ro/r.s)+.5)*r.s;\n    r.h=pcg3df(r.c);\n    r.i=i;\n\n    if(r.h.x<.4){\n      break;\n    }else if(i==0){\n      r.s=vec3(2,1,100);\n    }else if(i==1){\n      r.s=vec3(1,1,100);\n    }\n  }\n  \n  vec3 src=-(ro-r.c)/rd;\n  vec3 dst=abs(.501*r.s/rd);\n  vec3 bv=src+dst;\n  float b=min(min(bv.x,bv.y),bv.z);\n  r.d=b;\n  \n  return r;\n}\n\nfloat sdbox(vec3 p,vec3 s){\n  vec3 d=abs(p)-s;\n  return length(max(d,0.))+min(0.,max(max(d.x,d.y),d.z));\n}\n\nfloat sdbox(vec2 p,vec2 s){\n  vec2 d=abs(p)-s;\n  return length(max(d,0.))+min(0.,max(d.x,d.y));\n}\n\nvec4 map(vec3 p,Grid grid){\n  p-=grid.c;\n  p.z+=.4*sin(2.*iTime+1.*fract(grid.h.z*28.)+.3*(grid.c.x+grid.c.y));\n  \n  vec3 psize=grid.s/2.;\n  psize.z=1.;\n  psize-=.02;\n  float d=sdbox(p+vec3(0,0,1),psize)-.02;\n  \n  float pcol=1.;\n\n  vec3 pt=p;\n  \n  if(grid.i==0){//2x2\n    if(grid.h.y<.3){//speaker\n      vec3 c=vec3(0);\n      pt.xy*=r2d(PI/4.);\n      c.xy=lofir(pt.xy,.1);\n      pt=pt-c;\n      pt.xy*=r2d(-PI/4.);\n      \n      float r=.02*smoothstep(.9,.7,abs(p.x))*smoothstep(.9,.7,abs(p.y));\n      float hole=length(pt.xy)-r;\n      d=max(d,-hole);\n    }else if(grid.h.y<.5){//eq\n      vec3 c=vec3(0);\n      c.x=clamp(lofir(pt.x,.2),-.6,.6);\n      pt-=c;\n      float hole=sdbox(pt.xy,vec2(0.,.7))-.03;\n      d=max(d,-hole);\n      \n      pt.y-=.5-smoothstep(-.5,.5,sin(iTime+c.x+grid.h.z*100.));\n      float d2=sdbox(pt,vec3(.02,.07,.07))-.03;\n      \n      if(d2<d){\n        float l=step(abs(pt.y),.02);\n        return vec4(d2,2.*l,l,0);\n      }\n      \n      pt=p;\n      c.y=clamp(lofir(pt.y,.2),-.6,.6);\n      pt-=c;\n      pcol*=smoothstep(.0,.01,sdbox(pt.xy,vec2(.07,.0))-.005);\n\n      pt=p;\n      c.y=clamp(lofir(pt.y,.6),-.6,.6);\n      pt-=c;\n      pcol*=smoothstep(.0,.01,sdbox(pt.xy,vec2(.1,.0))-.01);\n      \n      pcol=mix(1.,pcol,smoothstep(.0,.01,sdbox(pt.xy,vec2(.03,1.))-.01));\n\n    }else if(grid.h.y<.6){//kaosspad\n      float hole=sdbox(p.xy,vec2(.9,.9)+.02);\n      d=max(d,-hole);\n\n      float d2=sdbox(p,vec3(.9,.9,.05));\n\n      if(d2<d){\n        float l=step(abs(p.x),.7)*step(abs(p.y),.7);\n        return vec4(d2,4.*l,0,0);\n      }\n    }else if(grid.h.y<1.){//bigass knob\n      float ani=smoothstep(-.5,.5,sin(iTime+grid.h.z*100.));\n      pt.xy*=r2d(PI/6.*5.*mix(-1.,1.,ani));\n\n      float metal=step(length(pt.xy),.45);\n      float wave=metal*sin(length(pt.xy)*500.)/1000.;\n      float d2=length(pt.xy)-.63+.05*pt.z-.02*cos(8.*atan(pt.y,pt.x));\n      d2=max(d2,abs(pt.z)-.4-wave);\n\n      float d2b=length(pt.xy)-.67+.05*pt.z;\n      d2b=max(d2b,abs(pt.z)-.04);\n      d2=min(d2,d2b);\n      \n      if(d2<d){\n        float l=smoothstep(.01,.0,length(pt.xy-vec2(0,.53))-.03);\n        return vec4(d2,3.*metal,l,0);\n      }\n      \n      pt=p;\n      float a=clamp(lofir(atan(-pt.x,pt.y),PI/12.),-PI/6.*5.,PI/6.*5.);\n      pt.xy*=r2d(a);\n      pcol*=smoothstep(.0,.01,length(pt.xy-vec2(0,.74))-.015);\n\n      pt=p;\n      a=clamp(lofir(atan(-pt.x,pt.y),PI/6.*5.),-PI/6.*5.,PI/6.*5.);\n      pt.xy*=r2d(a);\n      pcol*=smoothstep(.0,.01,length(pt.xy-vec2(0,.74))-.03);\n      \n      float d3=length(p-vec3(.7,-.7,0))-.05;\n      \n      if(d3<d){\n        float led=1.-ani;\n        led*=.5+.5*sin(iTime*exp2(3.+3.*grid.h.z));\n        return vec4(d3,2,led,0);\n      }\n    }\n  }else if(grid.i==1){//2x1\n    if(grid.h.y<.4){//fader\n      float hole=sdbox(p.xy,vec2(.9,.05));\n      d=max(d,-hole);\n      \n      float ani=smoothstep(-.2,.2,sin(iTime+grid.h.z*100.));\n      pt.x-=mix(-.8,.8,ani);\n      \n      float d2=sdbox(pt,vec3(.07,.25,.4))+.05*p.z;\n      d2=max(d2,-p.z);\n\n      if(d2<d){\n        float l=smoothstep(.01,.0,abs(p.y)-.02);\n        return vec4(d2,0,l,0);\n      }\n      \n      pt=p;\n      vec3 c=vec3(0);\n      c.x=clamp(lofir(pt.x,.2),-.8,.8);\n      pt-=c;\n      pcol*=smoothstep(.0,.01,sdbox(pt.xy,vec2(.0,.15))-.005);\n\n      pt=p;\n      c=vec3(0);\n      c.x=clamp(lofir(pt.x,.8),-.8,.8);\n      pt-=c;\n      pcol*=smoothstep(.0,.01,sdbox(pt.xy,vec2(.0,.18))-.01);\n      \n      pcol=mix(1.,pcol,smoothstep(.0,.01,sdbox(p.xy,vec2(1.,.08))));\n    }else if(grid.h.y<.5){//button\n      vec3 c=vec3(0);\n      c.x=clamp(lofi(pt.x,.44)+.44/2.,-.44*1.5,.44*1.5);\n      pt-=c;\n\n      float hole=sdbox(pt.xy,vec2(.19,.33))-.01;\n      d=max(d,-hole);\n      \n      float ani=smoothstep(.8,.9,sin(10.*iTime-c.x*2.2+grid.h.z*100.));\n\n      vec4 fuck=vec4(d,0,0,0);\n      float d3=length(pt-vec3(0,.22,.04))-.05;\n      \n      if(d3<fuck.x){\n        float led=ani;\n        fuck=vec4(d3,2,led,0);\n      }\n\n      float d2=sdbox(pt,vec3(.17,.3,.05))-.01;\n      d2=min(d2,sdbox(pt-vec3(0,-.1,0),vec3(.17,.2,.08))-.01)+.5*pt.z;\n\n      if(d2<fuck.x){\n        fuck=vec4(d2,5,fract(grid.h.z*8.89),0);\n      }\n      \n      if(fuck.x<d){\n        return fuck;\n      }\n      \n    }else if(grid.h.y<1.){//meter\n      float hole=sdbox(p.xy,vec2(.9,.3)+.02);\n      d=max(d,-hole);\n\n      float d2=sdbox(p,vec3(.9,.3,.1));\n\n      if(d2<d){\n        float l=step(abs(p.x),.8)*step(abs(p.y),.2);\n        return vec4(d2,l,0,0);\n      }\n    }\n  }else{//1x1\n    if(grid.h.y<.5){//knob\n      float hole=length(p.xy)-.25;\n      d=max(d,-hole);\n      \n      float ani=smoothstep(-.5,.5,sin(2.*iTime+grid.h.z*100.));\n      pt.xy*=r2d(PI/6.*5.*mix(-1.,1.,ani));\n      \n      float d2=length(pt.xy)-.23+.05*pt.z;\n      d2=max(d2,abs(pt.z)-.4);\n      \n      if(d2<d){\n        float l=smoothstep(.01,.0,abs(pt.x)-.015);\n        l*=smoothstep(.01,.0,-pt.y+.05);\n        return vec4(d2,0,l,0);\n      }\n      \n      pt=p;\n      float a=clamp(lofir(atan(-pt.x,pt.y),PI/6.),-PI/6.*5.,PI/6.*5.);\n      pt.xy*=r2d(a);\n      pcol*=smoothstep(.0,.01,sdbox(pt.xy-vec2(0,.34),vec2(.0,.02))-.005);\n\n      pt=p;\n      a=clamp(lofir(atan(-pt.x,pt.y),PI/6.*5.),-PI/6.*5.,PI/6.*5.);\n      pt.xy*=r2d(a);\n      pcol*=smoothstep(.0,.01,sdbox(pt.xy-vec2(0,.34),vec2(.0,.03))-.01);\n    }else if(grid.h.y<.8){//jack\n      float hole=length(p.xy)-.1;\n      d=max(d,-hole);\n      \n      float d2=length(p.xy)-.15;\n      d2=max(d2,abs(p.z)-.12);\n      \n      pt.xy*=r2d(100.*grid.h.z);\n      float d3=abs(pt.y)-.2;\n      pt.xy*=r2d(PI/3.*2.);\n      d3=max(d3,abs(pt.y)-.2);\n      pt.xy*=r2d(PI/3.*2.);\n      d3=max(d3,abs(pt.y)-.2);\n      d3=max(d3,abs(p.z)-.03);\n\n      d2=min(d2,d3);\n      d2=max(d2,-hole);\n      \n      if(d2<d){\n        return vec4(d2,3,0,0);\n      }\n    }else if(grid.h.y<.99){//button\n      pt.y+=.08;\n      \n      float hole=sdbox(pt.xy,vec2(.22))-.05;\n      d=max(d,-hole);\n      \n      float ani=sin(2.*iTime+grid.h.z*100.);\n      float push=smoothstep(.3,.0,abs(ani));\n      ani=smoothstep(-.1,.1,ani);\n      pt.z+=.06*push;\n\n      float d2=sdbox(pt,vec3(.2,.2,.05))-.05;\n\n      if(d2<d){\n        return vec4(d2,0,0,0);\n      }\n      \n      float d3=length(p-vec3(0,.3,0))-.05;\n      \n      if(d3<d){\n        float led=ani;\n        return vec4(d3,2,led,0);\n      }\n    }else if(grid.h.y<1.){//0b5vr\n      pt=abs(pt);\n      pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n      pcol*=smoothstep(.0,.01,sdbox(pt.xy,vec2(.05)));\n      pcol*=smoothstep(.0,.01,sdbox(pt.xy-vec2(.2,0),vec2(.05,.15)));\n      pcol=1.-pcol;\n    }\n  }\n  \n  return vec4(d,0,pcol,0);\n}\n\nvec3 nmap(vec3 p,Grid grid,float dd){\n  vec2 d=vec2(0,dd);\n  return normalize(vec3(\n    map(p+d.yxx,grid).x-map(p-d.yxx,grid).x,\n    map(p+d.xyx,grid).x-map(p-d.xyx,grid).x,\n    map(p+d.xxy,grid).x-map(p-d.xxy,grid).x\n  ));\n}\n\nstruct March{\n  vec4 isect;\n  vec3 rp;\n  float rl;\n  Grid grid;\n};\n\nMarch domarch(vec3 ro,vec3 rd,int iter){\n  float rl=1E-2;\n  vec3 rp=ro+rd*rl;\n  vec4 isect;\n  Grid grid;\n  float gridlen=rl;\n  \n  for(int i=0;i<iter;i++){\n    if(gridlen<=rl){\n      grid=dogrid(rp,rd);\n      gridlen+=grid.d;\n    }\n    \n    isect=map(rp,grid);\n    rl=min(rl+isect.x*.8,gridlen);\n    rp=ro+rd*rl;\n    \n    if(abs(isect.x)<1E-4){break;}\n    if(rl>50.){break;}\n  }\n  \n  March r;\n  r.isect=isect;\n  r.rp=rp;\n  r.rl=rl;\n  r.grid=grid;\n  \n  return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 p=uv*2.-1.;\n  p.x*=iResolution.x/iResolution.y;\n\n  vec3 col=vec3(0);\n\n  float canim=smoothstep(-.2,.2,sin(iTime));\n  vec3 co=mix(vec3(-6,-8,-40),vec3(0,-2,-40),canim);\n  vec3 ct=vec3(0,0,-50);\n  float cr=mix(.5,.0,canim);\n  co.xy+=iTime;\n  ct.xy+=iTime;\n  mat3 cb=orthbas(co-ct);\n  vec3 ro=co+cb*vec3(4.*p*r2d(cr),0);\n  vec3 rd=cb*normalize(vec3(0,0,-2));\n  \n  March march=domarch(ro,rd,100);\n  \n  if(march.isect.x<1E-2){\n    vec3 basecol=vec3(.5);\n    vec3 speccol=vec3(.2);\n    float specpow=30.;\n    float ndelta=1E-4;\n    \n    float mtl=march.isect.y;\n    float mtlp=march.isect.z;\n    if(mtl==0.){\n      mtlp=mix(mtlp,1.-mtlp,step(fract(march.grid.h.z*66.),.1));\n      vec3 c=.9+.0*sin(.1*(march.grid.c.x+march.grid.c.y)+march.grid.h.z+vec3(0,2,3));\n      basecol=mix(vec3(.04),c,mtlp);\n    }else if(mtl==1.){\n      basecol=vec3(0);\n      speccol=vec3(.5);\n      specpow=60.;\n      \n      vec2 size=vec2(.05,.2);\n      vec2 pp=(march.rp-march.grid.c).xy;\n      vec2 c=lofi(pp.xy,size)+size/2.;\n      vec2 cc=pp-c;\n      vec3 led=vec3(1);\n      led*=exp(-60.*sdbox(cc,vec2(0.,.08)));\n      led*=c.x>.5?vec3(5,1,2):vec3(1,5,2);\n      float lv=texture(iChannel0,vec2(march.grid.h.z,0)).x*1.;\n      col+=led*step(c.x,-.8+1.6*lv);\n      basecol=.04*led;\n    }else if(mtl==2.){\n      basecol=vec3(0);\n      speccol=vec3(1.);\n      specpow=100.;\n      \n      col+=mtlp*vec3(2,.5,.5);\n    }else if(mtl==3.){\n      basecol=vec3(.2);\n      speccol=vec3(1.8);\n      specpow=100.;\n      ndelta=3E-2;\n    }else if(mtl==4.){\n      basecol=vec3(0);\n      speccol=vec3(.5);\n      specpow=60.;\n      \n      vec2 size=vec2(.1);\n      vec2 pp=(march.rp-march.grid.c).xy;\n      vec2 c=lofi(pp.xy,size)+size/2.;\n      vec2 cc=pp-c;\n      vec3 led=vec3(1);\n      led*=exp(-60.*sdbox(cc,vec2(0.,.0)));\n      led*=vec3(2,1,2);\n      float plasma=sin(length(c)*10.-10.*iTime+march.grid.h.z*.7);\n      plasma+=sin(c.y*10.-7.*iTime);\n      led*=.5+.5*sin(plasma);\n      col+=2.*led;\n      basecol=.04*led;\n    }else if(mtl==5.){\n      basecol=vec3(.9,mtlp,.02);\n    }\n    \n    vec3 n=nmap(march.rp,march.grid,ndelta);\n    vec3 v=-rd;\n    \n    {\n      vec3 l=normalize(vec3(1,3,5));\n      vec3 h=normalize(l+v);\n      float dotnl=max(0.,dot(n,l));\n      float dotnh=max(0.,dot(n,h));\n      float shadow=step(1E-1,domarch(march.rp,l,30).isect.x);\n      vec3 diff=basecol/PI;\n      vec3 spec=speccol*pow(dotnh,specpow);\n      col+=vec3(.5,.6,.7)*shadow*dotnl*(diff+spec);\n    }\n    {\n      vec3 l=normalize(vec3(-1,-1,5));\n      vec3 h=normalize(l+v);\n      float dotnl=max(0.,dot(n,l));\n      float dotnh=max(0.,dot(n,h));\n      float shadow=step(1E-1,domarch(march.rp,l,30).isect.x);\n      vec3 diff=basecol/PI;\n      vec3 spec=speccol*pow(dotnh,specpow);\n      col+=shadow*dotnl*(diff+spec);\n    }\n  }\n  \n  col=pow(col,vec3(.4545));\n  col=smoothstep(vec3(0,-.1,-.2),vec3(1,1.1,1.2),col);\n  fragColor = vec4(col,0);\n}"
    },           
    "Fractal Tunnel": {
      "name": "Fractal Tunnel",
      "category": "FRACTAL PRESETS",
      "code": "float det=.001,t, boxhit;\nvec3 adv, boxp;\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 path(float t)\n    {\n    vec3 p=vec3(vec2(sin(t*.1),cos(t*.05))*10.,t);\n    p.x+=smoothstep(.0,.5,abs(.5-fract(t*.02)))*10.;\n    return p;\n}\n\nfloat fractal(vec2 p)\n{\n    p=abs(5.-mod(p*.2,10.))-5.;\n    float ot=1000.;\n    for (int i=0; i<7; i++)\n    {\n        p=abs(p)/clamp(p.x*p.y,.25,2.)-1.;\n        if(i>0)ot=min(ot,abs(p.x)+.7*fract(abs(p.y)*.05+t*.05+float(i)*.3));\n        \n    }\n    ot=exp(-10.*ot);\n    return ot;\n}\n\nfloat box(vec3 p, vec3 l)\n{\n    vec3 c=abs(p)-l;\n    return length(max(vec3(0.),c))+min(0.,max(c.x,max(c.y,c.z)));\n}\n\nfloat de(vec3 p)\n{\n    boxhit=0.;\n    vec3 p2=p-adv;\n    p2.xz*=rot(t*.2);\n    p2.xy*=rot(t*.1);\n    p2.yz*=rot(t*.15);\n    float b=box(p2,vec3(1.));\n    p.xy-=path(p.z).xy;\n    float s=sign(p.y);\n    p.y=-abs(p.y)-3.;\n    p.z=mod(p.z,20.)-10.;\n    for (int i=0; i<5; i++)\n    {\n        p=abs(p)-1.;\n        p.xz*=rot(radians(s*-45.));\n        p.yz*=rot(radians(90.));\n    }\n    float f=-box(p,vec3(5.,5.,10.));\n    float d=min(f,b);\n    if (d==b) boxp=p2, boxhit=1.;\n    return d*.7;\n}\n\n\nvec3 march(vec3 from, vec3 dir)\n{\n    vec3 p,n,g=vec3(0.);\n    float d, td=0.;\n    for (int i=0; i<80; i++)\n    {\n        p=from+td*dir;\n        d=de(p)*(1.-hash(gl_FragCoord.xy+t)*.3);\n        if (d<det && boxhit<.5) break;\n        td+=max(det,abs(d));\n        float f=fractal(p.xy)+fractal(p.xz)+fractal(p.yz);\n        //boxp*=.5;\n        float b=fractal(boxp.xy)+fractal(boxp.xz)+fractal(boxp.yz);\n        vec3 colf=vec3(f*f,f,f*f*f);\n        vec3 colb=vec3(b+.1,b*b+.05,0.);\n        g+=colf/(3.+d*d*2.)*exp(-.0015*td*td)*step(5.,td)/2.*(1.-boxhit);\n        g+=colb/(10.+d*d*20.)*boxhit*.5;\n    }\n    return g;\n}\n\nmat3 lookat(vec3 dir, vec3 up) \n{\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    t=iTime*7.;\n    vec3 from=path(t);\n    adv=path(t+6.+sin(t*.1)*3.);\n    vec3 dir=normalize(vec3(uv,.7));\n    dir=lookat(adv-from,vec3(0.,1.,0.))*dir;\n    vec3 col=march(from, dir);\n    fragColor=vec4(col,1.0);\n}"
    },    

    "neural_network": {
      "name": "Neural Network Universe",
      "category": "PROCEDURAL EFFECTS",
      "code": "#define S(a, b, t) smoothstep(a, b, t)\n#define NUM_LAYERS 4.\n\n//#define SIMPLE\n\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float n = N21(id+offs);\n    float n1 = fract(n*10.);\n    float n2 = fract(n*100.);\n    float a = t+n;\n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat GetT(vec2 ro, vec2 rd, vec2 p) {\n\treturn dot(p-ro, rd); \n}\n\nfloat LineDist(vec3 a, vec3 b, vec3 p) {\n\treturn length(cross(b-a, p-a))/length(p-a);\n}\n\nfloat df_line( in vec2 a, in vec2 b, in vec2 p)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat line(vec2 a, vec2 b, vec2 uv) {\n    float r1 = .04;\n    float r2 = .01;\n    \n    float d = df_line(a, b, uv);\n    float d2 = length(a-b);\n    float fade = S(1.5, .5, d2);\n    \n    fade += S(.05, .02, abs(d2-.75));\n    return S(r1, r2, d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float t) {\n    vec2 id = floor(st)+n;\n\n    st = fract(st)-.5;\n   \n    vec2 p[9];\n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    float m = 0.;\n    float sparkle = 0.;\n    \n    for(int i=0; i<9; i++) {\n        m += line(p[4], p[i], st);\n\n        float d = length(st-p[i]);\n\n        float s = (.005/(d*d));\n        s *= S(1., .7, d);\n        float pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*5.)*.4+.6;\n        pulse = pow(pulse, 20.);\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n    m += line(p[1], p[3], st);\n\tm += line(p[1], p[5], st);\n    m += line(p[7], p[5], st);\n    m += line(p[7], p[3], st);\n    \n    float sPhase = (sin(t+n)+sin(t*.1))*.25+.5;\n    sPhase += pow(sin(t*.1)*.5+.5, 50.)*5.;\n    m += sparkle*sPhase;//(*.5+.5);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tvec2 M = iMouse.xy/iResolution.xy-.5;\n    \n    float t = iTime*.1;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    vec2 st = uv*rot;  \n\tM *= rot*2.;\n    \n    float m = 0.;\n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float z = fract(t+i);\n        float size = mix(15., 1., z);\n        float fade = S(0., .6, z)*S(1., .8, z);\n        \n        m += fade * NetLayer(st*size-M*z, i, iTime);\n    }\n    \n\tfloat fft  = texelFetch( iChannel0, ivec2(.7,0), 0 ).x;\n    float glow = -uv.y*fft*2.;\n   \n    vec3 baseCol = vec3(s, cos(t*.4), -sin(t*.24))*.4+.6;\n    vec3 col = baseCol*m;\n    col += baseCol*glow;\n    \n    #ifdef SIMPLE\n    uv *= 10.;\n    col = vec3(1)*NetLayer(uv, 0., iTime);\n    uv = fract(uv);\n    //if(uv.x>.98 || uv.y>.98) col += 1.;\n    #else\n    col *= 1.-dot(uv,uv);\n    t = mod(iTime, 230.);\n    col *= S(0., 20., t)*S(224., 200., t);\n    #endif\n    \n    fragColor = vec4(col,1);\n}"
    },    
    "plasma": {
      "name": "Plasma Field",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float v = 0.0;\n    v += sin(p.x * 10.0 + time);\n    v += sin(p.y * 10.0 + time * 1.2);\n    v += sin((p.x + p.y) * 10.0 + time * 0.8);\n    v += sin(length(p) * 15.0 - time * 2.0);\n    v *= 0.25;\n    \n    vec3 col = vec3(\n        sin(v * 3.14159 + time * 0.5),\n        sin(v * 3.14159 + 2.094 + time * 0.3),\n        sin(v * 3.14159 + 4.189 + time * 0.7)\n    );\n    col = col * 0.5 + 0.5;\n    col = pow(col, vec3(1.5));\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "Octopus Tunnel": {
      "name": "Octopus Tunnel",
      "category": "FRACTAL PRESETS",
      "code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define SIN(x)  (.5+.5*sin(x))\n#define PI 3.141592\n#define PHI 1.618033988749895\n\n\nfloat tt, gl, mat, cid;\nvec3 ro;\n\n\n// from shadertoy user tdhopper\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nvec3 pal(float t) {\n        vec3 cols[] = vec3[](vec3(0.510,0.510,0.510), vec3(0.102,0.675,0.918), vec3(0.427,0.220,1.000), vec3(0.259,1.000,0.443), vec3(1.000,0.220,0.894));\n        return cols[int(t) % cols.length()];\n}\n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n// iq's impulse function\nfloat impulse2( float x, float k) {\n    \n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat impulse( float x, float k, float e) {\n    \n    float h = k*pow(x, e);\n    return h*exp(1.0-h);\n}\n\n// repetitive, continues pulse function for animation\nfloat continuesPulse(float x, float k, float e, float period) {\n   \n\treturn impulse(mod(x, period), k, e);\n    \n}\n\n// repetitive, continues pulse function for animation\nfloat continuesPulse2(float x, float k, float period) {\n   \n\treturn impulse2(mod(x, period), k);\n    \n}\n\n// remap [0,1] -> [a, b])\nfloat remap(float x, float a, float b) {\n    return a*x+b;\n}\n\n\nfloat cyl(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sph(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat cylcap( vec3 p, float r, float h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat ring(vec3 p, float h, float rout, float rin) {\n    return max(cylcap(p, h, rout), -cylcap(p, 2.*h, rin));\n}\n\nfloat box(vec3 p, vec3 r) {\n    vec3 d = abs(p) - r;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n/*\n\tp = abs(p) - r;\n    return max(p.x, max(p.y, p.z));\n}\n*/\n\nvec2 repeat(vec2 p, vec2 s) {\n    \treturn (fract(p/s-.5)-.5)*s;\n}\n\nfloat repeat(float p, float s) {\n    \treturn (fract(p/s-.5)-.5)*s;\n}\n\nfloat sdOctopus(vec3 p) {\n    float s = 0.4;\n    vec3 q = p;\n    \n    \n    q.z = abs(q.z);\n     \n    q.y = -abs(q.y);\n    q.yz *= rot(PI*0.25);\n    q.z = abs(q.z);\n    q.y = -abs(q.y);\n    q.yz *= rot(PI*0.125);\n    q.z = abs(q.z);\n   \n    q.xz *= rot(-PI*0.25);\n\n    q.xz -= 0.5;\n \n    int maxIter = 20;\n    float d = 1e6;\n    float alpha = remap(continuesPulse((tt), 0.7, 4.0, 5.0), -0.45, 0.15);\n\n    for(int i=1; i < maxIter; i++) { \n        q.xz *= rot(-alpha);\n        q.z-=10./float(maxIter);\n        s -= 0.8/float(maxIter);\n        float b = box(q, vec3(s))-.01;\n        d = min(d, b);              \n    }\n    \n    float head = fIcosahedron(p, .7);\n    \n    d = min(d, head);\n  \n    return d;\n}\n\n\nvec3 tunnel(vec3 p) {\n\tvec3 off = vec3(0);\n    off.x += sin(p.z*.1)*4.;\n    off.y += sin(p.z*.12)*3.;\n    return off;\n}\n\nvec2 moda(vec2 p, float s) {\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    a = (fract(a/s-.5)-.5)*s;\n    return r*vec2(cos(a), sin(a));\n       \n}\n\nfloat repeat2(inout float p, float size) {\n  float c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nvoid cam(inout vec3 p) {\n\tp.z += tt*5.;// + 7.*sin(.1*tt);\n    p -= tunnel(p);\n}\n\nfloat map(vec3 p) {\n\n    vec3 np = p;\n\n    float tunr = 10.;\n    float vrep = 10.;\n    \n    p += tunnel(p);\n   \n    vec3 vvp = p;\n    vvp.z += vrep/2.;\n    cid = 1.+(repeat2(vvp.z, vrep)/vrep)*10.;\n    float octo;\n    \n    {\n    \n        vec3 q = p;\n        float pulse = continuesPulse((tt), 0.7, 3.0, 5.0);\n        float pulse2 = continuesPulse2((tt-1.), 3., 5.0);\n  \n        q.z += 5.;\n        \n        q.z -= remap(pulse, 1.5, 10.0);   \\\n        q.z -= 1.5*tt + tt *remap(pulse2, 0., 3.5);\n                \n       // float oid = repeat2(q.z, 30.);\n        q.xz *= rot(-PI*.5);\n        vec3 o1 = q;\n        vec3 o2 = q;\n\n        o1.xy += vec2(-4.5*sin(tt), 3.3*cos(.4*tt));\n        //o2.x -= 5.0;\n\n        o1.xz *= rot(.4*sin(tt*.4));\n        float s = 1.8;\n        octo = 1./s*sdOctopus(o1/s);\n    }\n\n    vec3 bp = p;\n    vec3 vp = p;\n    vec3 cp = p;\n    vec3 sp = p;\n    \n\t\n    bp.x = atan(p.y, p.x)*30./3.1415;\n    bp.y = length(p.xy)-tunr;\n\n    \n    bp.xz = repeat(bp.xz, vec2(4));\n    bp.xz = abs(bp.xz) - 1.; \n    bp.x -= bp.z*.4;\n     \n    for(float i = 0.; i < 3.; i += 1.) {\n        bp.xz *= rot(tt*.1+cid);\n        //bp.yz *= rot(5.*i);\n      \n        bp.xz = abs(bp.xz) - 1. - .1*SIN(i*tt*.3);\n\n        bp.x += .1;\n \n    }\n      \n    float b = .9*box(bp, vec3(.8));\n\n\n    float dz = abs(ro.z-np.z);\n    float fade = exp(-sqrt(dz)*.4);\n    \n    cp.xy *= rot(.08*p.z);\n    cp.x = abs(cp.x) - 3.;\n    cp.x += sin(0.25*cp.y+sin(tt))*2.;\n    cp.z = repeat(cp.z, 5.);\n    \n    float vid = repeat2(vp.z, vrep);\n    vp.yz *= rot(PI*.5);\n    float veil = ring(vp, max(0., .01), tunr, tunr-.1);\n    \n    float gls = SIN(vid*2.+2.*tt);\n    gl += .018/(.1+pow(abs(veil), 8.));\n    \n    float tun = b;\n    \n   // repeat2(sp.z, vrep);\n    //sp.y -= 9.4;\n    //sp.z -= vrep/2.;\n    //float stone = .3*fIcosahedron(sp, 1.5);\n\n    mat = tun < octo ? 0. : 1.+cid;\n    \n    float d = min(tun, octo);\n    return d;\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    tt = 1.5*iTime;\n    \n    vec3 ls = vec3(0, 0, -10.0); // light source\n\tvec3 col = vec3(0);\n    \n    ro = vec3(0, 0, -20);\n    vec3 rd = normalize(vec3(-uv, .7)); \n    \n    vec3 gcol = vec3(0.467,0.706,0.933);\n\n    cam(ro);\n    cam(ls);\n    vec3 p = ro;\n    float d = 0.1;\n    \n    float l_mat = 0.;\n    float l_cid = 0.;\n    \n    float i, t= .1;\n    for(i=0.; i<150.; i++) {\n        d = map(p);\n        \n        if(d < 0.001 || d > 20.) break;\n        \n        p += d*rd;\n        t += d;\n        l_mat = mat;\n        l_cid = cid;     \n    }\n    \n    if(d < 0.001) {\n        vec2 e = vec2(0.0035, -0.0035);\n        \n        vec3 al = pal(l_cid);\n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        \n        vec3 l = normalize(ls-p);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n        float sss = smoothstep(0., 1., map(p+l*.4))/.4;\n        float ao = calcAO(p, n);\n\n        if(l_mat < 1.) {\n           // gcol = mix(gcol, al, .2);\n            col += pow(i/100., 1.2)*3.*gcol*exp(-t*t*0.001);\n        } else {\n            col +=  .2*spe+.8*al*(.3+.8*dif+1.5*sss) + .2*ao;\n          \n          \n        }\n    }\n    \n    col += 0.08*gl*gcol;\n           \n    col = pow(col, vec3(1.4));\n    fragColor = vec4(col,1.0);\n}"
    }, 
    "Fractal Noise": {
      "name": "Fractal Noise",
      "category": "FRACTAL PRESETS",
      "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv00 = fragCoord / iResolution.xy; //Original UV\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y; //Fractal Circle UV\n    vec2 uv0 = uv; //Circle UV\n    vec3 finalcol = vec3  (0.0);\n    float time = iTime; //Animation Speed\n\n    // Access webcam texture\n    vec3 camcol = texture(iChannel0, uv00).rgb;\n    \n    for (float i = 0.0; i < 4.0; i++) {\n    \n        uv = fract(uv * 1.5) - 0.5;\n        float d = length(uv) * exp(-length(uv0 * 1.5));\n        float d0 = length(uv0);\n        d = sin(d * (i + abs(cos(time)) - time * 0.5) + time) / 8.0;\n        d = smoothstep(0.01 / d, 1.5, d);\n        \n        float colr = sin(time * 2.0) * 0.3 + (uv.x * sin(time) * 0.1);\n        float colg = 0.4 / d0 * 0.1 - (uv.y * sin(time) * 0.1);\n        float colb = cos(time * 2.0) * cos(time) * (d0 * sin(time) * 0.2);\n        if (i >= 3.0) colb = colr;\n        vec3 col = vec3(colr, colg, colb);\n        finalcol += col * (d + abs(cos(time) * 0.1));\n        \n        camcol = smoothstep(-.1,.9,camcol);\n    }\n    // Combine final color with webcam texture\n    camcol-= finalcol*2.;\n    finalcol -= camcol*finalcol;\n\n    fragColor = vec4(finalcol, 1.0);\n}"
    },
    "Trippy Waves": {
      "name": "Trippy Waves",
      "category": "FRACTAL PRESETS",
      "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 0.5;\n\tvec2 uv = zoom * (fragCoord.xy - iResolution.xy / 2.0);\n        \n    float t = iTime * 3.1415;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \n    float pi = acos(-1.);\n        \n   \n    float m = 1.;\n    float n = 8.;\n    float p = 1.;\n    \n    float r = sqrt(x*x+y*y);\n    float th = atan(y, x);\n   \n    \n    float value = 0.;\n    \n    const int points = 7;\n    \n    for(int i = 0; i < points ; i++){\n      float angle = pi / float(points) * float(i);\n\n      float w = x * sin(angle) + y * cos(angle);\n\n\t  value += sin(w + t);\n    };\n\n        \n    float color = (sin(value * pi / 2.) + 1.) * 1.5;\n    \n    if(color > 0.0) {\n      fragColor = color - vec4(0,1.5,2,0); \n    } else {\n      //fragColor = vec4(med, med, low,1.0);\n      fragColor = -color - vec4(1,1.5,0,0); \n    }\n}"
    },
    "waves": {
      "name": "Quantum Waves",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float d = length(p);\n    float angle = atan(p.y, p.x);\n    \n    float wave1 = sin(d * 15.0 - time * 3.0) * 0.5 + 0.5;\n    float wave2 = sin(d * 20.0 + time * 2.0) * 0.5 + 0.5;\n    float wave3 = sin(angle * 8.0 + time) * 0.5 + 0.5;\n    \n    float pattern = wave1 * wave2 * wave3;\n    pattern *= exp(-d * 1.5);\n    \n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 1.0, 1.0) * pattern;\n    col += vec3(0.0, 0.5, 1.0) * wave1 * exp(-d * 2.0);\n    col += vec3(1.0, 0.0, 1.0) * wave2 * 0.3;\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    }      
  }
}    

    





   
    

    
    
