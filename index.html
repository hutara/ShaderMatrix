<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHADER MATRIX // Advanced Editor</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/material-ocean.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    
    <style>
        /* ========== RESET & BASE ========== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto Mono', monospace;
            background: #000;
            color: #0ff;
            overflow: hidden;
            position: relative;
            height: 100vh;
            touch-action: none;
        }

        /* ========== SHADER CANVAS ========== */
        #shader-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* ========== APP CONTAINER ========== */
        .app-container {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            height: 100vh;
            pointer-events: none;
        }

        .app-container > * {
            pointer-events: auto;
        }

        /* ========== HEADER ========== */
        .header {
            background: rgba(0, 10, 20, 0.95);
            border-bottom: 2px solid #0ff;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
            flex-wrap: wrap;
            gap: 10px;
        }

        .logo {
            font-family: 'Orbitron', monospace;
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: 900;
            text-shadow: 0 0 20px #0ff;
            letter-spacing: 2px;
        }

        .header-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* ========== BUTTONS ========== */
        .btn {
            background: linear-gradient(135deg, #001a33, #003366);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 8px 16px;
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            font-family: 'Roboto Mono', monospace;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-decoration: none;
            display: inline-block;
            white-space: nowrap;
        }

        .btn:hover {
            background: linear-gradient(135deg, #003366, #0066cc);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #1a0033, #330066);
            border-color: #f0f;
            color: #f0f;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #330066, #6600cc);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }

        /* ========== TOGGLE BUTTONS ========== */
        .toggle-btn {
            position: fixed;
            z-index: 1000;
            width: 40px;
            height: 40px;
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #0ff;
            color: #0ff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .toggle-btn:hover {
            background: rgba(0, 40, 80, 0.9);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        #sidebarToggle {
            top: 70px;
            left: 10px;
        }

        #editorToggle {
            top: 70px;
            right: 10px;
        }

        /* ========== SIDEBAR ========== */
        .sidebar {
            position: fixed;
            left: 0;
            top: 60px;
            width: 250px;
            height: calc(100vh - 60px);
            background: rgba(0, 10, 20, 0.95);
            border-right: 2px solid #0ff;
            overflow-y: auto;
            transition: transform 0.3s ease;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .sidebar.collapsed {
            transform: translateX(-100%);
        }

        .sidebar-section {
            padding: 15px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
        }

        .sidebar-title {
            font-size: 0.8rem;
            color: #f0f;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .preset-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(0, 40, 80, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.85rem;
        }

        .preset-item:hover {
            background: rgba(0, 80, 160, 0.5);
            border-color: #0ff;
            transform: translateX(5px);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        /* ========== EDITOR PANEL ========== */
        .editor-panel {
            position: fixed;
            right: 0;
            top: 60px;
            width: 45%;
            height: calc(100vh - 60px);
            background: rgba(0, 10, 20, 0.95);
            border-left: 2px solid #0ff;
            transition: transform 0.3s ease;
            z-index: 100;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            transform: translateX(100%); /* پیش‌فرض بسته */
        }

        .editor-panel.collapsed {
            transform: translateX(100%);
        }

        /* حالت باز */
        .editor-panel:not(.collapsed) {
            transform: translateX(0);
        }

        .panel-header {
            padding: 10px 15px;
            background: rgba(0, 20, 40, 0.8);
            border-bottom: 1px solid #0ff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        #statusText {
            color: #f0f;
            font-size: 0.8rem;
        }

        .editor-container {
            flex: 1;
            overflow: hidden;
        }

        /* ========== INFO PANEL ========== */
        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 10, 20, 0.9);
            padding: 10px 20px;
            border: 1px solid #0ff;
            border-radius: 5px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: clamp(0.7rem, 2vw, 0.9rem);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #0ff;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .info-label {
            color: #888;
            font-size: 0.8em;
        }

        .info-value {
            color: #0ff;
            font-weight: 500;
        }

        /* ========== FULLSCREEN MODE ========== */
        .fullscreen-exit-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            padding: 20px 40px;
            border: 2px solid #0ff;
            font-size: 1.2rem;
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        body.fullscreen-mode .fullscreen-exit-hint {
            opacity: 1;
            animation: fadeOut 3s forwards;
        }

        @keyframes fadeOut {
            0%, 70% { opacity: 1; }
            100% { opacity: 0; }
        }

        body.fullscreen-mode .header,
        body.fullscreen-mode .sidebar,
        body.fullscreen-mode .editor-panel,
        body.fullscreen-mode .info-panel,
        body.fullscreen-mode .toggle-btn {
            display: none;
        }

        /* ========== MOBILE RESPONSIVE ========== */
        @media (max-width: 768px) {
            .header {
                padding: 8px 10px;
            }

            .logo {
                font-size: 1rem;
                letter-spacing: 1px;
            }

            .header-controls {
                width: 100%;
                justify-content: center;
                gap: 5px;
            }

            .btn {
                padding: 6px 10px;
                font-size: 0.7rem;
            }

            .sidebar {
                width: 80%;
                max-width: 300px;
            }

            .editor-panel {
                width: 90%;
                max-width: 400px;
            }

            #sidebarToggle {
                top: auto;
                bottom: 70px;
                left: 10px;
            }

            #editorToggle {
                top: auto;
                bottom: 70px;
                right: 10px;
            }

            .info-panel {
                bottom: 10px;
                padding: 8px 15px;
                gap: 15px;
            }

            .info-item {
                font-size: 0.75rem;
            }

            /* دکمه‌های کوچکتر در موبایل */
            .toggle-btn {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
        }

        @media (max-width: 480px) {
            .header-controls {
                gap: 3px;
            }

            .btn {
                padding: 5px 8px;
                font-size: 0.65rem;
                letter-spacing: 0.5px;
            }

            .editor-panel {
                width: 100%;
            }

            .info-panel {
                gap: 10px;
                padding: 6px 10px;
            }

            .info-label {
                display: none;
            }
        }

        /* ========== SCROLLBAR STYLING ========== */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 20, 40, 0.5);
        }

        ::-webkit-scrollbar-thumb {
            background: #0ff;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #0aa;
        }
    </style>
</head>
<body>
    <canvas id="shader-canvas"></canvas>
    
    <div class="fullscreen-exit-hint">Press ESC to exit fullscreen</div>

    <button class="toggle-btn" id="sidebarToggle">
        <span class="toggle-icon">☰</span>
    </button>

    <button class="toggle-btn" id="editorToggle">
        <span class="toggle-icon">⟨⟩</span>
    </button>

    <div class="app-container">
        <header class="header">
            <div class="logo">◢ SHADER MATRIX ◣</div>
            <div class="header-controls">
                <button class="btn btn-secondary" id="compileBtn">COMPILE</button>
                <button class="btn" id="runBtn">RUN</button>
                <button class="btn" id="resetBtn">RESET</button>
                <button class="btn" id="pauseBtn">PAUSE</button>
                <button class="btn" id="fullscreenBtn">FULLSCREEN</button>
                <button class="btn" id="shareBtn">SHARE</button>
                <a href="./presets.html" class="btn">GALLERY</a>
            </div>
        </header>

        <aside class="sidebar collapsed" id="sidebar"></aside>

        <main class="main-content">
            <div class="editor-panel collapsed" id="editorPanel">
                <div class="panel-header">
                    <span>FRAGMENT SHADER CODE</span>
                    <span id="statusText">LOADING...</span>
                </div>
                <div class="editor-container">
                    <textarea id="codeEditor"></textarea>
                </div>
            </div>
        </main>
    </div>

    <div class="info-panel">
        <div class="info-item">
            <div class="status-dot"></div>
            <span class="info-label">FPS</span>
            <span class="info-value" id="fps">60</span>
        </div>
        <div class="info-item">
            <span class="info-label">TIME</span>
            <span class="info-value" id="time">0.00s</span>
        </div>
        <div class="info-item">
            <span class="info-label">RES</span>
            <span class="info-value" id="resolution">1920x1080</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/clike/clike.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>

    <script>
    // ============================================
    // UNIVERSAL SHADERTOY CONVERTER v4.0 FINAL
    // ============================================
    function convertShadertoyToGLSL(sourceCode) {
        // Already converted
        if (sourceCode.includes('void main()') && 
            sourceCode.includes('gl_FragColor') && 
            !sourceCode.includes('mainImage')) {
            return sourceCode;
        }

        let code = sourceCode;
        
        // === STEP 1: Replace ALL ShaderToy built-ins EVERYWHERE (including #defines) ===
        // Do this FIRST before extracting anything
        code = code.replace(/\biResolution\b/g, 'resolution');
        code = code.replace(/\biTime\b/g, 'time');
        code = code.replace(/\biTimeDelta\b/g, 'timeDelta');
        code = code.replace(/\biFrame\b/g, 'frame');
        code = code.replace(/\biMouse\b/g, 'mouse');
        code = code.replace(/\biDate\b/g, 'date');
        code = code.replace(/\biSampleRate\b/g, 'sampleRate');
        
        // Fix resolution.z -> resolution.x (vec3 to vec2 compatibility)
        code = code.replace(/\bresolution\.z\b/g, 'resolution.x');
        
        // === STEP 2: Extract preprocessor directives ===
        const directives = {
            defines: [],
            extensions: [],
            pragmas: []
        };
        
        code = code.replace(/^\s*#\s*define\s+[^\n]+/gm, (m) => {
            directives.defines.push(m);
            return '';
        });
        
        code = code.replace(/^\s*#\s*extension\s+[^\n]+/gm, (m) => {
            directives.extensions.push(m);
            return '';
        });
        
        code = code.replace(/^\s*#\s*pragma\s+[^\n]+/gm, (m) => {
            directives.pragmas.push(m);
            return '';
        });
        
        // === STEP 3: Process mainImage function ===
        const mainImageRegex = /void\s+mainImage\s*\(\s*out\s+vec4\s+(\w+)\s*,\s*in\s+vec2\s+(\w+)\s*\)\s*\{([\s\S]*)\}/;
        const match = code.match(mainImageRegex);
        
        let mainBody = '';
        let fragColorParam = 'fragColor';
        let fragCoordParam = 'fragCoord';
        
        if (match) {
            fragColorParam = match[1];
            fragCoordParam = match[2];
            mainBody = match[3];
            
            // Remove mainImage function from code
            code = code.replace(mainImageRegex, '');
        } else {
            // No mainImage found, use entire code as body
            mainBody = code;
            code = '';
        }
        
        // === STEP 4: Replace parameter names in main body ===
        const fragColorRegex = new RegExp(`\\b${fragColorParam}\\b`, 'g');
        const fragCoordRegex = new RegExp(`\\b${fragCoordParam}\\b`, 'g');
        
        mainBody = mainBody.replace(fragColorRegex, 'gl_FragColor');
        mainBody = mainBody.replace(fragCoordRegex, 'gl_FragCoord.xy');
        
        // === STEP 5: Fix GLSL ES compatibility ===
        // int() -> int(floor())
        mainBody = mainBody.replace(/\bint\s*\(\s*([^)]+)\s*\)/g, 'int(floor($1))');
        code = code.replace(/\bint\s*\(\s*([^)]+)\s*\)/g, 'int(floor($1))');
        
        // texture() -> texture2D()
        mainBody = mainBody.replace(/\btexture\s*\(/g, 'texture2D(');
        code = code.replace(/\btexture\s*\(/g, 'texture2D(');
        
        // === STEP 6: Build final shader ===
        let output = '';
        
        // Precision
        output += `#ifdef GL_ES
    precision highp float;
    #endif

    `;
        
        // Extensions
        if (mainBody.includes('dFdx') || mainBody.includes('dFdy') || mainBody.includes('fwidth') ||
            code.includes('dFdx') || code.includes('dFdy') || code.includes('fwidth')) {
            output += `#extension GL_OES_standard_derivatives : enable\n`;
        }
        
        if (directives.extensions.length > 0) {
            output += directives.extensions.join('\n') + '\n';
        }
        
        output += '\n';
        
        // Pragmas
        if (directives.pragmas.length > 0) {
            output += directives.pragmas.join('\n') + '\n\n';
        }
        
        // Defines
        if (directives.defines.length > 0) {
            output += directives.defines.join('\n') + '\n\n';
        }
        
        // Uniforms (use vec2 for compatibility with .x and .y access)
        const hasUniforms = code.includes('uniform ') || mainBody.includes('uniform ');
        if (!hasUniforms) {
            output += `uniform vec2 resolution;
    uniform float time;
    uniform float timeDelta;
    uniform int frame;
    uniform vec4 mouse;
    uniform vec4 date;
    uniform float sampleRate;
    uniform sampler2D iChannel0;
    uniform sampler2D iChannel1;
    uniform sampler2D iChannel2;
    uniform sampler2D iChannel3;

    `;
        }
        
        // Helper functions
        if (code.trim().length > 0) {
            output += code.trim() + '\n\n';
        }
        
        // Main function
        output += `void main() {\n${mainBody}\n}\n`;
        
        // Clean up
        output = output.replace(/\n{3,}/g, '\n\n');
        
        return output;
    }

    // ============================================
    // FALLBACK PRESETS
    // ============================================
    const FALLBACK_PRESETS = {
        plasma: {
            name: "Plasma Field",
            code: `uniform vec2 resolution;
    uniform float time;

    void main() {
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        vec2 p = (uv - 0.5) * 2.0;
        p.x *= resolution.x / resolution.y;
        
        float v = 0.0;
        v += sin(p.x * 10.0 + time);
        v += sin(p.y * 10.0 + time * 1.2);
        v += sin((p.x + p.y) * 10.0 + time * 0.8);
        v += sin(length(p) * 15.0 - time * 2.0);
        v *= 0.25;
        
        vec3 col = vec3(
            sin(v * 3.14159 + time * 0.5),
            sin(v * 3.14159 + 2.094 + time * 0.3),
            sin(v * 3.14159 + 4.189 + time * 0.7)
        );
        col = col * 0.5 + 0.5;
        col = pow(col, vec3(1.5));
        
        gl_FragColor = vec4(col, 1.0);
    }`
        },
        matrix: {
            name: "Matrix Rain",
            code: `uniform vec2 resolution;
    uniform float time;

    float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
    }

    void main() {
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        float cols = 60.0;
        float colId = floor(uv.x * cols);
        float speed = hash(vec2(colId, 0.0)) * 2.0 + 0.5;
        float offset = hash(vec2(colId, 1.0)) * 100.0;
        float y = fract(uv.y + time * speed * 0.15 + offset);
        float char = hash(vec2(colId, floor(y * 40.0)));
        float intensity = char * (1.0 - y);
        float head = smoothstep(0.98, 1.0, y);
        vec3 col = vec3(0.0, intensity, 0.0);
        col += vec3(0.5, 1.0, 0.5) * head;
        col *= smoothstep(0.0, 0.05, y);
        gl_FragColor = vec4(col, 1.0);
    }`
        }
    };

    class ShaderEngine {
        constructor() {
            this.canvas = document.getElementById('shader-canvas');
            this.paused = false;
            this.presets = null;
            this.currentShader = '';
            this.startTime = performance.now();
            this.frameCount = 0;
            
            this.initRenderer();
            this.initEditor();
            
            // ادیتور را در ابتدا بسته نگه می‌داریم
            document.getElementById('editorPanel').classList.add('collapsed');
            document.getElementById('sidebar').classList.add('collapsed');
            
            this.loadPresets().then(() => {
                this.initEventListeners();
                this.loadFromStorage();
                this.loadFromURL();
                this.setupFPSCounter();
                this.animate();
            });
        }

        async loadPresets() {
            try {
                const response = await fetch('./assets/presets.json');
                if (!response.ok) throw new Error('Failed to load presets.json');
                const data = await response.json();
                this.presets = data.presets || data;
                this.setStatus(`LOADED ${Object.keys(this.presets).length} PRESETS`);
                console.log('✓ Loaded presets from JSON');
            } catch (error) {
                console.warn('⚠ Failed to load presets.json, using fallback');
                this.presets = FALLBACK_PRESETS;
                this.setStatus('USING FALLBACK PRESETS');
            }
            
            this.currentShader = this.presets.matrix?.code || this.presets[Object.keys(this.presets)[0]]?.code || '';
            this.editor.setValue(this.currentShader);
            this.updateShader(this.currentShader);
            this.populateSidebar();
        }

        populateSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.innerHTML = '';
            const categories = { 'SHADER PRESETS': [], 'VISUAL EFFECTS': [] };
            
            Object.entries(this.presets).forEach(([key, preset]) => {
                const category = preset.category || 'SHADER PRESETS';
                if (!categories[category]) categories[category] = [];
                categories[category].push({ key, ...preset });
            });
            
            Object.entries(categories).forEach(([categoryName, items]) => {
                if (items.length === 0) return;
                const section = document.createElement('div');
                section.className = 'sidebar-section';
                const title = document.createElement('div');
                title.className = 'sidebar-title';
                title.textContent = categoryName;
                section.appendChild(title);
                items.forEach(item => {
                    const btn = document.createElement('div');
                    btn.className = 'preset-item';
                    btn.dataset.preset = item.key;
                    btn.textContent = item.name || item.key;
                    section.appendChild(btn);
                });
                sidebar.appendChild(section);
            });
        }

        initRenderer() {
            this.renderer = new THREE.WebGLRenderer({ 
                canvas: this.canvas,
                antialias: true,
                alpha: false
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // محدود کردن pixel ratio
            
            this.scene = new THREE.Scene();
            this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            
            // Use vec2 for resolution (not vec3)
            this.uniforms = {
                time: { value: 0 },
                timeDelta: { value: 0 },
                frame: { value: 0 },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                mouse: { value: new THREE.Vector4(0, 0, 0, 0) },
                date: { value: new THREE.Vector4(0, 0, 0, 0) },
                sampleRate: { value: 44100 }
            };
        }

        updateShader(fragmentShader) {
            try {
                let glslCode = fragmentShader;
                const isShaderToy = fragmentShader.includes('mainImage') || 
                                fragmentShader.includes('iResolution') || 
                                fragmentShader.includes('iTime');
                
                if (isShaderToy) {
                    glslCode = convertShadertoyToGLSL(fragmentShader);
                    console.log('✓ Converted ShaderToy → GLSL');
                }
                
                const geometry = new THREE.PlaneGeometry(2, 2);
                const material = new THREE.ShaderMaterial({
                    uniforms: this.uniforms,
                    vertexShader: `void main() { gl_Position = vec4(position, 1.0); }`,
                    fragmentShader: glslCode,
                    extensions: { derivatives: true }
                });

                if (this.mesh) {
                    this.scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.scene.add(this.mesh);
                
                this.setStatus('COMPILED ✓');
                console.log('✓ Shader compiled successfully');
                return true;
            } catch (error) {
                this.setStatus('SHADER ERROR');
                console.error('✗ Shader compilation error:', error);
                alert(`Shader Error:\n${error.message}\n\nCheck console for details.`);
                return false;
            }
        }

        initEditor() {
            this.editor = CodeMirror.fromTextArea(document.getElementById('codeEditor'), {
                mode: 'text/x-csrc',
                theme: 'material-ocean',
                lineNumbers: true,
                indentUnit: 4,
                tabSize: 4,
                matchBrackets: true,
                autoCloseBrackets: true,
                lineWrapping: true // اضافه شده برای responsive بودن
            });
            this.editor.setSize('100%', '100%');
            this.editor.on('change', () => {
                localStorage.setItem('shaderCode', this.editor.getValue());
            });
        }

        loadFromStorage() {
            const saved = localStorage.getItem('shaderCode');
            if (saved && saved !== this.currentShader) {
                this.editor.setValue(saved);
                this.currentShader = saved;
                this.updateShader(saved);
                this.setStatus('LOADED FROM STORAGE');
            }
        }

        loadFromURL() {
            const urlParams = new URLSearchParams(location.search);
            const shared = urlParams.get('s');
            if (shared) {
                try {
                    const code = LZString.decompressFromEncodedURIComponent(shared);
                    if (code) {
                        this.editor.setValue(code);
                        this.currentShader = code;
                        this.updateShader(code);
                        this.setStatus('LOADED FROM URL');
                    }
                } catch (e) {
                    console.error('Failed to load from URL:', e);
                }
            }
        }

        initEventListeners() {
            // Toggle sidebar
            document.getElementById('sidebarToggle').onclick = () => {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.toggle('collapsed');
                
                // در موبایل، ادیتور را ببند وقتی سایدبار باز می‌شود
                if (window.innerWidth <= 768 && !sidebar.classList.contains('collapsed')) {
                    document.getElementById('editorPanel').classList.add('collapsed');
                }
            };

            // Toggle editor
            document.getElementById('editorToggle').onclick = () => {
                const editor = document.getElementById('editorPanel');
                editor.classList.toggle('collapsed');
                
                // Refresh CodeMirror when showing
                if (!editor.classList.contains('collapsed')) {
                    setTimeout(() => this.editor.refresh(), 300);
                    
                    // در موبایل، سایدبار را ببند وقتی ادیتور باز می‌شود
                    if (window.innerWidth <= 768) {
                        document.getElementById('sidebar').classList.add('collapsed');
                    }
                }
            };

            document.getElementById('compileBtn').onclick = () => {
                this.updateShader(this.editor.getValue());
            };

            document.getElementById('runBtn').onclick = () => {
                const code = this.editor.getValue();
                if (this.updateShader(code)) {
                    this.currentShader = code;
                    localStorage.setItem('shaderCode', code);
                }
            };

            document.getElementById('resetBtn').onclick = () => {
                const defaultShader = this.presets.matrix?.code || this.currentShader;
                this.editor.setValue(defaultShader);
                this.currentShader = defaultShader;
                this.updateShader(this.currentShader);
                localStorage.setItem('shaderCode', this.currentShader);
            };

            document.getElementById('pauseBtn').onclick = () => {
                this.paused = !this.paused;
                document.getElementById('pauseBtn').textContent = this.paused ? 'RESUME' : 'PAUSE';
                this.setStatus(this.paused ? 'PAUSED' : 'RUNNING');
            };

            document.getElementById('fullscreenBtn').onclick = () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                    document.body.classList.remove('fullscreen-mode');
                } else {
                    document.documentElement.requestFullscreen();
                    document.body.classList.add('fullscreen-mode');
                }
            };

            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) {
                    document.body.classList.remove('fullscreen-mode');
                }
            });

            document.getElementById('shareBtn').onclick = () => {
                const compressed = LZString.compressToEncodedURIComponent(this.editor.getValue());
                const url = `${location.origin}${location.pathname}?s=${compressed}`;
                
                // استفاده از Clipboard API با fallback
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(url).then(() => {
                        this.setStatus('LINK COPIED!');
                    }).catch(() => {
                        this.fallbackCopy(url);
                    });
                } else {
                    this.fallbackCopy(url);
                }
            };

            // Fallback copy method
            this.fallbackCopy = (text) => {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    this.setStatus('LINK COPIED!');
                } catch (err) {
                    this.setStatus('COPY FAILED');
                }
                document.body.removeChild(textarea);
            };

            document.getElementById('sidebar').addEventListener('click', (e) => {
                const btn = e.target.closest('.preset-item');
                if (!btn) return;
                const presetKey = btn.dataset.preset;
                if (this.presets && this.presets[presetKey]) {
                    const code = this.presets[presetKey].code;
                    this.editor.setValue(code);
                    this.currentShader = code;
                    this.updateShader(code);
                    localStorage.setItem('shaderCode', code);
                    this.setStatus(`LOADED: ${this.presets[presetKey].name}`);
                    
                    // در موبایل، سایدبار را ببند بعد از انتخاب
                    if (window.innerWidth <= 768) {
                        setTimeout(() => {
                            document.getElementById('sidebar').classList.add('collapsed');
                        }, 300);
                    }
                }
            });

            // Mouse/Touch events
            const handlePointerMove = (e) => {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX || e.touches?.[0]?.clientX || 0) - rect.left;
                const y = window.innerHeight - ((e.clientY || e.touches?.[0]?.clientY || 0) - rect.top);
                this.uniforms.mouse.value.set(x, y, e.buttons || (e.touches?.length > 0 ? 1 : 0), e.buttons || 0);
            };

            this.canvas.addEventListener('mousemove', handlePointerMove);
            this.canvas.addEventListener('touchmove', handlePointerMove, { passive: true });

            // Resize handler with debounce
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                    document.getElementById('resolution').textContent = 
                        `${window.innerWidth}x${window.innerHeight}`;
                    
                    // Refresh editor on resize
                    if (!document.getElementById('editorPanel').classList.contains('collapsed')) {
                        this.editor.refresh();
                    }
                }, 250);
            });

            // Prevent zoom on double tap (iOS)
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
        }

        setupFPSCounter() {
            let lastTime = performance.now();
            let frames = 0;
            setInterval(() => {
                const now = performance.now();
                const fps = Math.round(frames * 1000 / (now - lastTime));
                document.getElementById('fps').textContent = fps;
                frames = 0;
                lastTime = now;
            }, 1000);
            const countFrame = () => {
                frames++;
                requestAnimationFrame(countFrame);
            };
            countFrame();
        }

        setStatus(text) {
            const el = document.getElementById('statusText');
            el.textContent = text;
            clearTimeout(this._statusTimeout);
            this._statusTimeout = setTimeout(() => {
                if (el.textContent === text) el.textContent = 'READY';
            }, 2500);
        }

        animate() {
            requestAnimationFrame(() => this.animate());
            if (!this.paused) {
                const currentTime = performance.now();
                this.uniforms.time.value = (currentTime - this.startTime) * 0.001;
                this.uniforms.timeDelta.value = 0.016;
                this.uniforms.frame.value = this.frameCount++;
                const d = new Date();
                this.uniforms.date.value.set(
                    d.getFullYear(), d.getMonth(), d.getDate(),
                    d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds()
                );
            }
            document.getElementById('time').textContent = this.uniforms.time.value.toFixed(2) + 's';
            this.renderer.render(this.scene, this.camera);
        }
    }

    window.addEventListener('DOMContentLoaded', () => {
        new ShaderEngine();
        document.getElementById('resolution').textContent = `${window.innerWidth}x${window.innerHeight}`;
    });
    </script>
</body>
</html>

