{
  "presets": {
    "mandelbulb": {
      "name": "Mandelbulb 3D",
      "category": "FRACTAL SHADERS",
      "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat stime, ctime;\nvoid ry(inout vec3 p, float a){\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.x = c * q.x + s * q.z;\n\tp.z = -s * q.x + c * q.z;\n}\n\nfloat pixel_size = 0.0;\n\nvec3 mb(vec3 p) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.0;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 7; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n\t\tphi = asin(z.z / r);\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\nvec3 f(vec3 p){\n\try(p, iTime*0.2);\n\treturn mb(p);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float k ){\n\tfloat akuma=1.0,h=0.0;\n\tfloat t = 0.01;\n\tfor(int i=0; i < 50; ++i){\n\t\th=f(ro+rd*t).x;\n\t\tif(h<0.001)return 0.02;\n\t\takuma=min(akuma, k*h/t);\n\t\tt+=clamp(h,0.01,2.0);\n\t}\n\treturn akuma;\n}\n\nvec3 nor( in vec3 pos )\n{\n\tvec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n\t\tf(pos+eps.xyy).x - f(pos-eps.xyy).x,\n\t\tf(pos+eps.yxy).x - f(pos-eps.yxy).x,\n\t\tf(pos+eps.yyx).x - f(pos-eps.yyx).x ) );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat t = 1.0;\n\tfloat res_t = 0.0;\n\tfloat res_d = 1000.0;\n\tvec3 c, res_c;\n\tfloat max_error = 1000.0;\n\tfloat d = 1.0;\n\tfloat pd = 100.0;\n\tfloat os = 0.0;\n\tfloat step = 0.0;\n\tfloat error = 1000.0;\n\t\n\tfor( int i=0; i<48; i++ )\n\t{\n\t\tif( error < pixel_size*0.5 || t > 20.0 )\n\t\t{\n\t\t}\n\t\telse{\n\t\t\tc = f(ro + rd*t);\n\t\t\td = c.x;\n\n\t\t\tif(d > os)\n\t\t\t{\n\t\t\t\tos = 0.4 * d*d/pd;\n\t\t\t\tstep = d + os;\n\t\t\t\tpd = d;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstep =-os; os = 0.0; pd = 100.0; d = 1.0;\n\t\t\t}\n\n\t\t\terror = d / t;\n\n\t\t\tif(error < max_error)\n\t\t\t{\n\t\t\t\tmax_error = error;\n\t\t\t\tres_t = t;\n\t\t\t\tres_c = c;\n\t\t\t}\n\t\t\n\t\t\tt += step;\n\t\t}\n\t}\n\tif( t>20.0 ) res_t=-1.0;\n\treturn vec3(res_t, res_c.y, res_c.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q=fragCoord.xy/iResolution.xy;\n\tvec2 uv = -1.0 + 2.0*q;\n\tuv.x*=iResolution.x/iResolution.y;\n\t\n\tpixel_size = 1.0/(iResolution.x * 3.0);\n\tstime=0.7+0.3*sin(iTime*0.4);\n\tctime=0.7+0.3*cos(iTime*0.4);\n\n\tvec3 ta=vec3(0.0,0.0,0.0);\n\tvec3 ro = vec3(0.0, 3.*stime*ctime, 3.*(1.-stime*ctime));\n\n\tvec3 cf = normalize(ta-ro);\n\tvec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0)));\n\tvec3 cu = normalize(cross(cs,cf));\n\tvec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf);\n\n\tvec3 sundir = normalize(vec3(0.1, 0.8, 0.6));\n\tvec3 sun = vec3(1.64, 1.27, 0.99);\n\tvec3 skycolor = vec3(0.6, 1.5, 1.0);\n\n\tvec3 bg = exp(uv.y-2.0)*vec3(0.4, 1.6, 1.0);\n\n\tfloat halo=clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.0);\n\tvec3 col=bg+vec3(1.0,0.8,0.4)*pow(halo,17.0);\n\n\tvec3 res = intersect(ro, rd);\n\tif(res.x > 0.0){\n\t\tvec3 p = ro + res.x * rd;\n\t\tvec3 n=nor(p);\n\t\tfloat shadow = softshadow(p, sundir, 10.0 );\n\n\t\tfloat dif = max(0.0, dot(n, sundir));\n\t\tfloat sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0)));\n\t\tfloat bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0);\n\t\tfloat spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0));\n\n\t\tvec3 lin = 4.5 * sun * dif * shadow;\n\t\tlin += 0.8 * bac * sun;\n\t\tlin += 0.6 * sky * skycolor*shadow;\n\t\tlin += 3.0 * spe * shadow;\n\n\t\tres.y = pow(clamp(res.y, 0.0, 1.0), 0.55);\n\t\tvec3 tc0 = 0.5 + 0.5 * sin(3.0 + 4.2 * res.y + vec3(0.0, 0.5, 1.0));\n\t\tcol = lin *vec3(0.9, 0.8, 0.6) * 0.2 * tc0;\n\t\tcol=mix(col,bg, 1.0-exp(-0.001*res.x*res.x));\n\t}\n\n\tcol=pow(clamp(col,0.0,1.0),vec3(0.45));\n\tcol=col*0.6+0.4*col*col*(3.0-2.0*col);\n\tcol=mix(col, vec3(dot(col, vec3(0.33))), -0.5);\n\tcol*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n\tfragColor = vec4(col.xyz, 1.0);\n}"
    },

    "galaxy": {
      "name": "Galaxy Spiral",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float angle = atan(p.y, p.x);\n    float radius = length(p);\n    \n    float spiral = angle + radius * 5.0 - time * 0.5;\n    float arms = sin(spiral * 3.0) * exp(-radius * 0.8);\n    arms = smoothstep(0.0, 1.0, arms * 0.5 + 0.5);\n    \n    float stars = step(0.97, hash(floor(uv * 200.0)));\n    stars *= exp(-radius * 1.5);\n    \n    vec3 core = vec3(1.0, 0.8, 0.5) * exp(-radius * 3.0);\n    vec3 armColor = vec3(0.3, 0.5, 1.0) * arms;\n    vec3 starColor = vec3(1.0) * stars;\n    \n    vec3 col = core + armColor + starColor;\n    col += vec3(0.05, 0.02, 0.1);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    
    },

    "electric": {
      "name": "Electric Orbs",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    for(float i = 0.0; i < 8.0; i++) {\n        float angle = time * (0.5 + i * 0.1) + i * 0.8;\n        vec2 pos = vec2(cos(angle), sin(angle)) * 0.5;\n        float d = length(p - pos);\n        \n        float glow = 0.015 / d;\n        vec3 color = vec3(0.2, 0.5 + sin(time + i) * 0.5, 1.0);\n        col += color * glow;\n    }\n    \n    col += vec3(0.5, 0.8, 1.0) * pow(col.b, 2.0);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "tunnel": {
      "name": "Infinite Tunnel",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float angle = atan(p.y, p.x);\n    float radius = length(p);\n    \n    vec2 tuv = vec2(angle / 3.14159, 0.5 / radius);\n    tuv.y -= time * 0.5;\n    tuv.x += time * 0.2;\n    \n    float pattern1 = sin(tuv.x * 20.0) * sin(tuv.y * 20.0);\n    float pattern2 = sin(tuv.x * 15.0 + tuv.y * 15.0);\n    \n    float final = pattern1 * pattern2;\n    final = final * 0.5 + 0.5;\n    \n    vec3 col = vec3(final);\n    col *= vec3(0.2, 0.8, 1.0);\n    col *= 1.0 - radius * 0.6;\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "fractal": {
      "name": "Fractal Noise",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float n = 0.0;\n    float amp = 0.5;\n    vec2 pos = p * 2.0;\n    \n    for(int i = 0; i < 5; i++) {\n        n += noise(pos + time * 0.3) * amp;\n        pos *= 2.0;\n        amp *= 0.5;\n    }\n    \n    vec3 col = vec3(n);\n    col = pow(col, vec3(1.5));\n    col *= vec3(0.5 + sin(time) * 0.5, 0.7, 1.0);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "hexagon": {
      "name": "Hexagon Grid",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvec2 hexCoord(vec2 p) {\n    vec2 r = vec2(1.0, 1.732);\n    vec2 h = r * 0.5;\n    vec2 a = mod(p, r) - h;\n    vec2 b = mod(p - h, r) - h;\n    return dot(a, a) < dot(b, b) ? a : b;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 10.0;\n    p.x *= resolution.x / resolution.y;\n    \n    vec2 hc = hexCoord(p);\n    float d = length(hc);\n    \n    float hex = smoothstep(0.5, 0.48, d);\n    float pulse = sin(d * 3.0 - time * 2.0) * 0.5 + 0.5;\n    \n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 1.0, 1.0) * hex * 0.5;\n    col += vec3(0.0, 0.5, 1.0) * hex * pulse;\n    col += vec3(1.0, 0.0, 1.0) * (1.0 - smoothstep(0.48, 0.5, d)) * 0.5;\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "voronoi": {
      "name": "Voronoi Cells",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvec2 hash2(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = uv * 8.0;\n    p.x *= resolution.x / resolution.y;\n    \n    vec2 gv = fract(p);\n    vec2 id = floor(p);\n    \n    float minDist = 100.0;\n    vec2 minPoint;\n    \n    for(float y = -1.0; y <= 1.0; y++) {\n        for(float x = -1.0; x <= 1.0; x++) {\n            vec2 offset = vec2(x, y);\n            vec2 neighbor = hash2(id + offset);\n            neighbor += offset;\n            neighbor += sin(time + neighbor * 6.28) * 0.3;\n            \n            float dist = length(gv - neighbor);\n            if(dist < minDist) {\n                minDist = dist;\n                minPoint = neighbor;\n            }\n        }\n    }\n    \n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 1.0, 0.5) * (1.0 - minDist);\n    col += vec3(0.0, 0.5, 1.0) * smoothstep(0.02, 0.0, minDist);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "glitch": {
      "name": "Digital Glitch",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    \n    float glitchStrength = step(0.9, hash(vec2(time * 0.5)));\n    float blockY = floor(uv.y * 20.0);\n    float glitchOffset = (hash(vec2(blockY, floor(time * 10.0))) - 0.5) * 0.1 * glitchStrength;\n    \n    vec2 glitchUV = uv;\n    glitchUV.x += glitchOffset;\n    \n    vec3 col = vec3(0.0);\n    col.r = step(0.5, fract(glitchUV.x * 10.0 + time));\n    col.g = step(0.5, fract(glitchUV.y * 10.0 - time));\n    col.b = step(0.5, fract((glitchUV.x + glitchUV.y) * 10.0));\n    \n    col *= vec3(0.0, 1.0, 1.0);\n    \n    float scanline = sin(uv.y * resolution.y * 0.5) * 0.1;\n    col += scanline;\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "MandelbulbX": {
      "name": "MandelbulbX",
      "category": "FRACTAL PRESETS",
      "code": "#define BOUNDING_RADIUS 1.1\n\n#define COLOR1 vec3(1.0, 0.3, 0.0)\n#define COLOR2 vec3(0.0, 0.7, 1.0)\n#define BACKGROUND vec3(0.9, 0.8, 0.8)\n\n#define ir3 0.57735\n\nfloat mandelbulb(vec3 pos){\n    vec3 w = pos;\n    float dr = 1.0,r;\n    vec3 p,p2,p4;\n    float k1,k2,k3,k4,k5;\n\n    for (int i = 0; i < 10; i++){\n        r = dot(w, w);\n        if (r > 4.0) break;\n        dr =  pow(r, 3.5)*8.0*dr + 1.0;\n\n        p = w;\n        p2 = w * w;\n        p4 = p2 * p2;\n\n        k3 = p2.x + p2.z;\n        k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        k1 = dot(p4, vec3(1)) - 6.0 * dot(p2, vec3(p2.y, p2.z, -p2.x / 3.0));\n        k4 = dot(p2, vec3(1, -1, 1));\n        k5 = 8.0*p.y*k4*k1*k2;\n\n        w = pos + vec3(8.0*k5*p.x*p.z*(p2.x-p2.z)*(p4.x-6.0*p2.x*p2.z+p4.z),\n                       -16.0*p2.y*k3*k4*k4 + k1*k1,\n                       -k5*(p4.x*p4.x - 28.0*p4.x*p2.x*p2.z + \n                            70.0*p4.x*p4.z - 28.0*p2.x*p2.z*p4.z + p4.z*p4.z));\n    }\n    return log(r)*sqrt(r)/dr;\n}\n\nfloat dist(vec3 p) {\n    return 0.385*mandelbulb(p);\n}\n\nbool bounding(in vec3 ro, in vec3 rd){\n    float b = dot(rd,ro);\n    return dot(ro,ro) - b*b < BOUNDING_RADIUS * BOUNDING_RADIUS;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n    if (bounding(ro, rd)){\n        float t = 0.72, d;\n        for (int i = 0; i < 96; i++){\n            d = dist(ro + rd * t);\n            t += d;\n\n            if (d < 0.002) return vec2(t, d);\n            if (d > 0.4) return vec2(-1.0);\n        }\n    }\n\n    return vec2(-1.0);\n}\n\nvec3 normal(vec3 p){\n    const float eps = 0.005;\n    return normalize(vec3(dist(p+vec3(eps,0,0))-dist(p-vec3(eps,0,0)),\n                          dist(p+vec3(0,eps,0))-dist(p-vec3(0,eps,0)),\n                          dist(p+vec3(0,0,eps))-dist(p-vec3(0,0,eps))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float theta = iTime * 0.2;\n    mat2 rot = mat2(+cos(theta), -sin(theta),\n                    +sin(theta), +cos(theta));\n    mat2 rrot = mat2(+cos(theta), +sin(theta),\n                     -sin(theta), +cos(theta));\n    vec2 rxz = vec2(0.0, -1.8) * rot;\n    vec3 ro = vec3(rxz.x, sin(theta*1.61)*0.1, rxz.y);\n    //coordinates of pixel\n    vec2 uv = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n\n\n    vec3 rd = normalize(vec3(uv, 1.1));\n    rd.xz *= rot;\n\n    vec2 res = march(ro, rd);\n\n    if (res.x > 0.0){\n        vec3 end = ro + rd * res.x;\n\n        vec3 norm = normal(end-rd*0.001);\n\n        float ao = clamp((dist(end + norm * 0.02) - res.y) / 0.02, 0.0, 1.0);\n        norm.xz *= rrot;\n\n        float m = clamp(dot(end, end), 0.0, BOUNDING_RADIUS) / BOUNDING_RADIUS;\n        vec3 col = mix(COLOR1, COLOR2, m*m*m);\n\n        float d = max(dot(norm, vec3(-ir3)), 0.0);\n        vec3 light = col * ao + 0.2 * d + 0.4 * d*d*d*d*d*d*d*d;\n\n        fragColor = vec4(light, 1.0);\n    } else {\n        fragColor = vec4(BACKGROUND - length(uv) / 4.0, 1.0);\n    }\n}"
    },   
    "Fractal Tunnel": {
      "name": "Fractal Tunnel",
      "category": "FRACTAL PRESETS",
      "code": "float det=.001,t, boxhit;\nvec3 adv, boxp;\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 path(float t)\n    {\n    vec3 p=vec3(vec2(sin(t*.1),cos(t*.05))*10.,t);\n    p.x+=smoothstep(.0,.5,abs(.5-fract(t*.02)))*10.;\n    return p;\n}\n\nfloat fractal(vec2 p)\n{\n    p=abs(5.-mod(p*.2,10.))-5.;\n    float ot=1000.;\n    for (int i=0; i<7; i++)\n    {\n        p=abs(p)/clamp(p.x*p.y,.25,2.)-1.;\n        if(i>0)ot=min(ot,abs(p.x)+.7*fract(abs(p.y)*.05+t*.05+float(i)*.3));\n        \n    }\n    ot=exp(-10.*ot);\n    return ot;\n}\n\nfloat box(vec3 p, vec3 l)\n{\n    vec3 c=abs(p)-l;\n    return length(max(vec3(0.),c))+min(0.,max(c.x,max(c.y,c.z)));\n}\n\nfloat de(vec3 p)\n{\n    boxhit=0.;\n    vec3 p2=p-adv;\n    p2.xz*=rot(t*.2);\n    p2.xy*=rot(t*.1);\n    p2.yz*=rot(t*.15);\n    float b=box(p2,vec3(1.));\n    p.xy-=path(p.z).xy;\n    float s=sign(p.y);\n    p.y=-abs(p.y)-3.;\n    p.z=mod(p.z,20.)-10.;\n    for (int i=0; i<5; i++)\n    {\n        p=abs(p)-1.;\n        p.xz*=rot(radians(s*-45.));\n        p.yz*=rot(radians(90.));\n    }\n    float f=-box(p,vec3(5.,5.,10.));\n    float d=min(f,b);\n    if (d==b) boxp=p2, boxhit=1.;\n    return d*.7;\n}\n\n\nvec3 march(vec3 from, vec3 dir)\n{\n    vec3 p,n,g=vec3(0.);\n    float d, td=0.;\n    for (int i=0; i<80; i++)\n    {\n        p=from+td*dir;\n        d=de(p)*(1.-hash(gl_FragCoord.xy+t)*.3);\n        if (d<det && boxhit<.5) break;\n        td+=max(det,abs(d));\n        float f=fractal(p.xy)+fractal(p.xz)+fractal(p.yz);\n        //boxp*=.5;\n        float b=fractal(boxp.xy)+fractal(boxp.xz)+fractal(boxp.yz);\n        vec3 colf=vec3(f*f,f,f*f*f);\n        vec3 colb=vec3(b+.1,b*b+.05,0.);\n        g+=colf/(3.+d*d*2.)*exp(-.0015*td*td)*step(5.,td)/2.*(1.-boxhit);\n        g+=colb/(10.+d*d*20.)*boxhit*.5;\n    }\n    return g;\n}\n\nmat3 lookat(vec3 dir, vec3 up) \n{\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    t=iTime*7.;\n    vec3 from=path(t);\n    adv=path(t+6.+sin(t*.1)*3.);\n    vec3 dir=normalize(vec3(uv,.7));\n    dir=lookat(adv-from,vec3(0.,1.,0.))*dir;\n    vec3 col=march(from, dir);\n    fragColor=vec4(col,1.0);\n}"
    },    
    "Matrix Rain": {
      "name": "Matrix Rain",
      "category": "FRACTAL PRESETS",
      "code": "/*\n  Feel free to do anything you want with this code.\n  This shader uses \"runes\" code by FabriceNeyret2[](https://www.shadertoy.com/view/4ltyDM)\n  which is based on \"runes\" by otaviogood[](https://shadertoy.com/view/MsXSRn).\n  These random runes look good as matrix symbols and have acceptable performance.\n*/\n\nconst int ITERATIONS = 40;   //use less value if you need more performance\nconst float SPEED = 1.;\n\nconst float STRIP_CHARS_MIN =  7.;\nconst float STRIP_CHARS_MAX = 40.;\nconst float STRIP_CHAR_HEIGHT = 0.15;\nconst float STRIP_CHAR_WIDTH = 0.10;\nconst float ZCELL_SIZE = 1. * (STRIP_CHAR_HEIGHT * STRIP_CHARS_MAX);  //the multiplier can't be less than 1.\nconst float XYCELL_SIZE = 12. * STRIP_CHAR_WIDTH;  //the multiplier can't be less than 1.\n\nconst int BLOCK_SIZE = 10;  //in cells\nconst int BLOCK_GAP = 2;    //in cells\n\nconst float WALK_SPEED = 1. * XYCELL_SIZE;\nconst float BLOCKS_BEFORE_TURN = 3.;\n\n\nconst float PI = 3.14159265359;\n\n\n//        ----  random  ----\n\nfloat hash(float v) {\n    return fract(sin(v)*43758.5453123);\n}\n\nfloat hash(vec2 v) {\n    return hash(dot(v, vec2(5.3983, 5.4427)));\n}\n\nvec2 hash2(vec2 v)\n{\n    v = vec2(v * mat2(127.1, 311.7,  269.5, 183.3));\n\treturn fract(sin(v)*43758.5453123);\n}\n\nvec4 hash4(vec2 v)\n{\n    vec4 p = vec4(v * mat4x2( 127.1, 311.7,\n                              269.5, 183.3,\n                              113.5, 271.9,\n                              246.1, 124.6 ));\n    return fract(sin(p)*43758.5453123);\n}\n\nvec4 hash4(vec3 v)\n{\n    vec4 p = vec4(v * mat4x3( 127.1, 311.7, 74.7,\n                              269.5, 183.3, 246.1,\n                              113.5, 271.9, 124.6,\n                              271.9, 269.5, 311.7 ) );\n    return fract(sin(p)*43758.5453123);\n}\n\n\n//        ----  symbols  ----\n//  Slightly modified version of \"runes\" by FabriceNeyret2 -  https://www.shadertoy.com/view/4ltyDM\n//  Which is based on \"runes\" by otaviogood -  https://shadertoy.com/view/MsXSRn\n\nfloat rune_line(vec2 p, vec2 a, vec2 b) {   // from https://www.shadertoy.com/view/4dcfW8\n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n\treturn length(p - b * h);                         // dist to segment\n}\n\nfloat rune(vec2 U, vec2 seed, float highlight)\n{\n\tfloat d = 1e5;\n\tfor (int i = 0; i < 4; i++)\t// number of strokes\n\t{\n        vec4 pos = hash4(seed);\n\t\tseed += 1.;\n\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) pos.y = .0;\n\t\tif (i == 1) pos.x = .999;\n\t\tif (i == 2) pos.x = .0;\n\t\tif (i == 3) pos.y = .999;\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec4 snaps = vec4(2, 3, 2, 3);\n\t\tpos = ( floor(pos * snaps) + .5) / snaps;\n\n\t\tif (pos.xy != pos.zw)  //filter out single points (when start and end are the same)\n\t\t    d = min(d, rune_line(U, pos.xy, pos.zw + .001) ); // closest line\n\t}\n\treturn smoothstep(0.1, 0., d) + highlight*smoothstep(0.4, 0., d);\n}\n\nfloat random_char(vec2 outer, vec2 inner, float highlight) {\n    vec2 seed = vec2(dot(outer, vec2(269.5, 183.3)), dot(outer, vec2(113.5, 271.9)));\n    return rune(inner, seed, highlight);\n}\n\n\n//        ----  digital rain  ----\n\n// xy - horizontal, z - vertical\nvec3 rain(vec3 ro3, vec3 rd3, float time) {\n    vec4 result = vec4(0.);\n\n    // normalized 2d projection\n    vec2 ro2 = vec2(ro3);\n    vec2 rd2 = normalize(vec2(rd3));\n\n    // we use formulas `ro3 + rd3 * t3` and `ro2 + rd2 * t2`, `t3_to_t2` is a multiplier to convert t3 to t2\n    bool prefer_dx = abs(rd2.x) > abs(rd2.y);\n    float t3_to_t2 = prefer_dx ? rd3.x / rd2.x : rd3.y / rd2.y;\n\n    // at first, horizontal space (xy) is divided into cells (which are columns in 3D)\n    // then each xy-cell is divided into vertical cells (along z) - each of these cells contains one raindrop\n\n    ivec3 cell_side = ivec3(step(0., rd3));      //for positive rd.x use cell side with higher x (1) as the next side, for negative - with lower x (0), the same for y and z\n    ivec3 cell_shift = ivec3(sign(rd3));         //shift to move to the next cell\n\n    //  move through xy-cells in the ray direction\n    float t2 = 0.;  // the ray formula is: ro2 + rd2 * t2, where t2 is positive as the ray has a direction.\n    ivec2 next_cell = ivec2(floor(ro2/XYCELL_SIZE));  //first cell index where ray origin is located\n    for (int i=0; i<ITERATIONS; i++) {\n        ivec2 cell = next_cell;  //save cell value before changing\n        float t2s = t2;          //and t\n\n        //  find the intersection with the nearest side of the current xy-cell (since we know the direction, we only need to check one vertical side and one horizontal side)\n        vec2 side = vec2(next_cell + cell_side.xy) * XYCELL_SIZE;  //side.x is x coord of the y-axis side, side.y - y of the x-axis side\n        vec2 t2_side = (side - ro2) / rd2;  // t2_side.x and t2_side.y are two candidates for the next value of t2, we need the nearest\n        if (t2_side.x < t2_side.y) {\n            t2 = t2_side.x;\n            next_cell.x += cell_shift.x;  //cross through the y-axis side\n        } else {\n            t2 = t2_side.y;\n            next_cell.y += cell_shift.y;  //cross through the x-axis side\n        }\n        //now t2 is the value of the end point in the current cell (and the same point is the start value in the next cell)\n\n        //  gap cells\n        vec2 cell_in_block = fract(vec2(cell) / float(BLOCK_SIZE));\n        float gap = float(BLOCK_GAP) / float(BLOCK_SIZE);\n        if (cell_in_block.x < gap || cell_in_block.y < gap || (cell_in_block.x < (gap+0.1) && cell_in_block.y < (gap+0.1))) {\n            continue;\n        }\n\n        //  return to 3d - we have start and end points of the ray segment inside the column (t3s and t3e)\n        float t3s = t2s / t3_to_t2;\n\n        //  move through z-cells of the current column in the ray direction (don't need much to check, two nearest cells are enough)\n        float pos_z = ro3.z + rd3.z * t3s;\n        float xycell_hash = hash(vec2(cell));\n        float z_shift = xycell_hash*11. - time * (0.5 + xycell_hash * 1.0 + xycell_hash * xycell_hash * 1.0 + pow(xycell_hash, 16.) * 3.0);  //a different z shift for each xy column\n        float char_z_shift = floor(z_shift / STRIP_CHAR_HEIGHT);\n        z_shift = char_z_shift * STRIP_CHAR_HEIGHT;\n        int zcell = int(floor((pos_z - z_shift)/ZCELL_SIZE));  //z-cell index\n        for (int j=0; j<2; j++) {  //2 iterations is enough if camera doesn't look much up or down\n            //  calcaulate coordinates of the target (raindrop)\n            vec4 cell_hash = hash4(vec3(ivec3(cell, zcell)));\n            vec4 cell_hash2 = fract(cell_hash * vec4(127.1, 311.7, 271.9, 124.6));\n\n            float chars_count = cell_hash.w * (STRIP_CHARS_MAX - STRIP_CHARS_MIN) + STRIP_CHARS_MIN;\n            float target_length = chars_count * STRIP_CHAR_HEIGHT;\n            float target_rad = STRIP_CHAR_WIDTH / 2.;\n            float target_z = (float(zcell)*ZCELL_SIZE + z_shift) + cell_hash.z * (ZCELL_SIZE - target_length);\n            vec2 target = vec2(cell) * XYCELL_SIZE + target_rad + cell_hash.xy * (XYCELL_SIZE - target_rad*2.);\n\n            //  We have a line segment (t0,t). Now calculate the distance between line segment and cell target (it's easier in 2d)\n            vec2 s = target - ro2;\n            float tmin = dot(s, rd2);  //tmin - point with minimal distance to target\n            if (tmin >= t2s && tmin <= t2) {\n                float u = s.x * rd2.y - s.y * rd2.x;  //horizontal coord in the matrix strip\n                if (abs(u) < target_rad) {\n                    u = (u/target_rad + 1.) / 2.;\n                    float z = ro3.z + rd3.z * tmin/t3_to_t2;\n                    float v = (z - target_z) / target_length;  //vertical coord in the matrix strip\n                    if (v >= 0.0 && v < 1.0) {\n                        float c = floor(v * chars_count);  //symbol index relative to the start of the strip, with addition of char_z_shift it becomes an index relative to the whole cell\n                        float q = fract(v * chars_count);\n                        vec2 char_hash = hash2(vec2(c+char_z_shift, cell_hash2.x));\n                        if (char_hash.x >= 0.1 || c == 0.) {  //10% of missed symbols\n                            float time_factor = floor(c == 0. ? time*5.0 :  //first symbol is changed fast\n                                    time*(1.0*cell_hash2.z +   //strips are changed sometime with different speed\n                                            cell_hash2.w*cell_hash2.w*4.*pow(char_hash.y, 4.)));  //some symbols in some strips are changed relatively often\n                            float a = random_char(vec2(char_hash.x, time_factor), vec2(u,q), max(1., 3. - c/2.)*0.2);  //alpha\n                            a *= clamp((chars_count - 0.5 - c) / 2., 0., 1.);  //tail fade\n                            if (a > 0.) {\n                                float attenuation = 1. + pow(0.06*tmin/t3_to_t2, 2.);\n                                vec3 col = (c == 0. ? vec3(0.67, 1.0, 0.82) : vec3(0.25, 0.80, 0.40)) / attenuation;\n                                float a1 = result.a;\n                                result.a = a1 + (1. - a1) * a;\n                                result.xyz = (result.xyz * a1 + col * (1. - a1) * a) / result.a;\n                                if (result.a > 0.98)  return result.xyz;\n                            }\n                        }\n                    }\n                }\n            }\n            // not found in this cell - go to next vertical cell\n            zcell += cell_shift.z;\n        }\n        // go to next horizontal cell\n    }\n\n    return result.xyz * result.a;\n}\n\n\n//        ----  main, camera  ----\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n\tfloat c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nvec3 rotateX(vec3 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(1.,0.,0.,0.,c,-s,0.,s,c) * v;\n}\n\nvec3 rotateY(vec3 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(c,0.,-s,0.,1.,0.,s,0.,c) * v;\n}\n\nvec3 rotateZ(vec3 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(c,-s,0.,s,c,0.,0.,0.,1.) * v;\n}\n\nfloat smoothstep1(float x) {\n    return smoothstep(0., 1., x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (STRIP_CHAR_WIDTH > XYCELL_SIZE || STRIP_CHAR_HEIGHT * STRIP_CHARS_MAX > ZCELL_SIZE) {\n        // error\n        fragColor = vec4(1., 0., 0., 1.);\n        return;\n    }\n\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\n    float time = iTime * SPEED;\n\n    const float turn_rad = 0.25 / BLOCKS_BEFORE_TURN;   //0 .. 0.5\n    const float turn_abs_time = (PI/2.*turn_rad) * 1.5;  //multiplier different than 1 means a slow down on turns\n    const float turn_time = turn_abs_time / (1. - 2.*turn_rad + turn_abs_time);  //0..1, but should be <= 0.5\n\n    float level1_size = float(BLOCK_SIZE) * BLOCKS_BEFORE_TURN * XYCELL_SIZE;\n    float level2_size = 4. * level1_size;\n    float gap_size = float(BLOCK_GAP) * XYCELL_SIZE;\n\n    vec3 ro = vec3(gap_size/2., gap_size/2., 0.);\n    vec3 rd = vec3(uv.x, 2.0, uv.y);\n\n    float tq = fract(time / (level2_size*4.) * WALK_SPEED);  //the whole cycle time counter\n    float t8 = fract(tq*4.);  //time counter while walking on one of the four big sides\n    float t1 = fract(t8*8.);  //time counter while walking on one of the eight sides of the big side\n\n    vec2 prev;\n    vec2 dir;\n    if (tq < 0.25) {\n        prev = vec2(0.,0.);\n        dir = vec2(0.,1.);\n    } else if (tq < 0.5) {\n        prev = vec2(0.,1.);\n        dir = vec2(1.,0.);\n    } else if (tq < 0.75) {\n        prev = vec2(1.,1.);\n        dir = vec2(0.,-1.);\n    } else {\n        prev = vec2(1.,0.);\n        dir = vec2(-1.,0.);\n    }\n    float angle = floor(tq * 4.);  //0..4 wich means 0..2*PI\n\n    prev *= 4.;\n\n    const float first_turn_look_angle = 0.4;\n    const float second_turn_drift_angle = 0.5;\n    const float fifth_turn_drift_angle = 0.25;\n\n    vec2 turn;\n    float turn_sign = 0.;\n    vec2 dirL = rotate(dir, -PI/2.);\n    vec2 dirR = -dirL;\n    float up_down = 0.;\n    float rotate_on_turns = 1.;\n    float roll_on_turns = 1.;\n    float add_angel = 0.;\n    if (t8 < 0.125) {\n        turn = dirL;\n        //dir = dir;\n        turn_sign = -1.;\n        angle -= first_turn_look_angle * (max(0., t1 - (1. - turn_time*2.)) / turn_time - max(0., t1 - (1. - turn_time)) / turn_time * 2.5);\n        roll_on_turns = 0.;\n    } else if (t8 < 0.250) {\n        prev += dir;\n        turn = dir;\n        dir = dirL;\n        angle -= 1.;\n        turn_sign = 1.;\n        add_angel += first_turn_look_angle*0.5 + (-first_turn_look_angle*0.5+1.0+second_turn_drift_angle)*t1;\n        rotate_on_turns = 0.;\n        roll_on_turns = 0.;\n    } else if (t8 < 0.375) {\n        prev += dir + dirL;\n        turn = dirR;\n        //dir = dir;\n        turn_sign = 1.;\n        add_angel += second_turn_drift_angle*sqrt(1.-t1);\n        //roll_on_turns = 0.;\n    } else if (t8 < 0.5) {\n        prev += dir + dir + dirL;\n        turn = dirR;\n        dir = dirR;\n        angle += 1.;\n        turn_sign = 0.;\n        up_down = sin(t1*PI) * 0.37;\n    } else if (t8 < 0.625) {\n        prev += dir + dir;\n        turn = dir;\n        dir = dirR;\n        angle += 1.;\n        turn_sign = -1.;\n        up_down = sin(-min(1., t1/(1.-turn_time))*PI) * 0.37;\n    } else if (t8 < 0.750) {\n        prev += dir + dir + dirR;\n        turn = dirL;\n        //dir = dir;\n        turn_sign = -1.;\n        add_angel -= (fifth_turn_drift_angle + 1.) * smoothstep1(t1);\n        rotate_on_turns = 0.;\n        roll_on_turns = 0.;\n    } else if (t8 < 0.875) {\n        prev += dir + dir + dir + dirR;\n        turn = dir;\n        dir = dirL;\n        angle -= 1.;\n        turn_sign = 1.;\n        add_angel -= fifth_turn_drift_angle - smoothstep1(t1) * (fifth_turn_drift_angle * 2. + 1.);\n        rotate_on_turns = 0.;\n        roll_on_turns = 0.;\n    } else {\n        prev += dir + dir + dir;\n        turn = dirR;\n        //dir = dir;\n        turn_sign = 1.;\n        angle += fifth_turn_drift_angle * (1.5*min(1., (1.-t1)/turn_time) - 0.5*smoothstep1(1. - min(1.,t1/(1.-turn_time))));\n    }\n\n    if (iMouse.x > 10. || iMouse.y > 10.) {\n        vec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n        up_down = -0.7 * mouse.y;\n        angle += mouse.x;\n        rotate_on_turns = 1.;\n        roll_on_turns = 0.;\n    } else {\n        angle += add_angel;\n    }\n\n    rd = rotateX(rd, up_down);\n\n    vec2 p;\n    if (turn_sign == 0.) {\n        //  move forward\n        p = prev + dir * (turn_rad + 1. * t1);\n    }\n    else if (t1 > (1. - turn_time)) {\n        //  turn\n        float tr = (t1 - (1. - turn_time)) / turn_time;\n        vec2 c = prev + dir * (1. - turn_rad) + turn * turn_rad;\n        p = c + turn_rad * rotate(dir, (tr - 1.) * turn_sign * PI/2.);\n        angle += tr * turn_sign * rotate_on_turns;\n        rd = rotateY(rd, sin(tr*turn_sign*PI) * 0.2 * roll_on_turns);  //roll\n    }  else  {\n        //  move forward\n        t1 /= (1. - turn_time);\n        p = prev + dir * (turn_rad + (1. - turn_rad*2.) * t1);\n    }\n\n    rd = rotateZ(rd, angle * PI/2.);\n\n    ro.xy += level1_size * p;\n\n    ro += rd * 0.2;\n    rd = normalize(rd);\n\n    vec3 col = rain(ro, rd, time);\n\n    fragColor = vec4(col, 1.);\n}"
    },
    "neural_network": {
      "name": "Neural Network Universe",
      "category": "PROCEDURAL EFFECTS",
      "code": "#define S(a, b, t) smoothstep(a, b, t)\n#define NUM_LAYERS 4.\n\n//#define SIMPLE\n\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float n = N21(id+offs);\n    float n1 = fract(n*10.);\n    float n2 = fract(n*100.);\n    float a = t+n;\n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat GetT(vec2 ro, vec2 rd, vec2 p) {\n\treturn dot(p-ro, rd); \n}\n\nfloat LineDist(vec3 a, vec3 b, vec3 p) {\n\treturn length(cross(b-a, p-a))/length(p-a);\n}\n\nfloat df_line( in vec2 a, in vec2 b, in vec2 p)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat line(vec2 a, vec2 b, vec2 uv) {\n    float r1 = .04;\n    float r2 = .01;\n    \n    float d = df_line(a, b, uv);\n    float d2 = length(a-b);\n    float fade = S(1.5, .5, d2);\n    \n    fade += S(.05, .02, abs(d2-.75));\n    return S(r1, r2, d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float t) {\n    vec2 id = floor(st)+n;\n\n    st = fract(st)-.5;\n   \n    vec2 p[9];\n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    float m = 0.;\n    float sparkle = 0.;\n    \n    for(int i=0; i<9; i++) {\n        m += line(p[4], p[i], st);\n\n        float d = length(st-p[i]);\n\n        float s = (.005/(d*d));\n        s *= S(1., .7, d);\n        float pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*5.)*.4+.6;\n        pulse = pow(pulse, 20.);\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n    m += line(p[1], p[3], st);\n\tm += line(p[1], p[5], st);\n    m += line(p[7], p[5], st);\n    m += line(p[7], p[3], st);\n    \n    float sPhase = (sin(t+n)+sin(t*.1))*.25+.5;\n    sPhase += pow(sin(t*.1)*.5+.5, 50.)*5.;\n    m += sparkle*sPhase;//(*.5+.5);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tvec2 M = iMouse.xy/iResolution.xy-.5;\n    \n    float t = iTime*.1;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    vec2 st = uv*rot;  \n\tM *= rot*2.;\n    \n    float m = 0.;\n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float z = fract(t+i);\n        float size = mix(15., 1., z);\n        float fade = S(0., .6, z)*S(1., .8, z);\n        \n        m += fade * NetLayer(st*size-M*z, i, iTime);\n    }\n    \n\tfloat fft  = texelFetch( iChannel0, ivec2(.7,0), 0 ).x;\n    float glow = -uv.y*fft*2.;\n   \n    vec3 baseCol = vec3(s, cos(t*.4), -sin(t*.24))*.4+.6;\n    vec3 col = baseCol*m;\n    col += baseCol*glow;\n    \n    #ifdef SIMPLE\n    uv *= 10.;\n    col = vec3(1)*NetLayer(uv, 0., iTime);\n    uv = fract(uv);\n    //if(uv.x>.98 || uv.y>.98) col += 1.;\n    #else\n    col *= 1.-dot(uv,uv);\n    t = mod(iTime, 230.);\n    col *= S(0., 20., t)*S(224., 200., t);\n    #endif\n    \n    fragColor = vec4(col,1);\n}"
    },    
    "plasma": {
      "name": "Plasma Field",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float v = 0.0;\n    v += sin(p.x * 10.0 + time);\n    v += sin(p.y * 10.0 + time * 1.2);\n    v += sin((p.x + p.y) * 10.0 + time * 0.8);\n    v += sin(length(p) * 15.0 - time * 2.0);\n    v *= 0.25;\n    \n    vec3 col = vec3(\n        sin(v * 3.14159 + time * 0.5),\n        sin(v * 3.14159 + 2.094 + time * 0.3),\n        sin(v * 3.14159 + 4.189 + time * 0.7)\n    );\n    col = col * 0.5 + 0.5;\n    col = pow(col, vec3(1.5));\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "Octopus Tunnel": {
      "name": "Octopus Tunnel",
      "category": "FRACTAL PRESETS",
      "code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define SIN(x)  (.5+.5*sin(x))\n#define PI 3.141592\n#define PHI 1.618033988749895\n\n\nfloat tt, gl, mat, cid;\nvec3 ro;\n\n\n// from shadertoy user tdhopper\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nvec3 pal(float t) {\n        vec3 cols[] = vec3[](vec3(0.510,0.510,0.510), vec3(0.102,0.675,0.918), vec3(0.427,0.220,1.000), vec3(0.259,1.000,0.443), vec3(1.000,0.220,0.894));\n        return cols[int(t) % cols.length()];\n}\n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n// iq's impulse function\nfloat impulse2( float x, float k) {\n    \n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat impulse( float x, float k, float e) {\n    \n    float h = k*pow(x, e);\n    return h*exp(1.0-h);\n}\n\n// repetitive, continues pulse function for animation\nfloat continuesPulse(float x, float k, float e, float period) {\n   \n\treturn impulse(mod(x, period), k, e);\n    \n}\n\n// repetitive, continues pulse function for animation\nfloat continuesPulse2(float x, float k, float period) {\n   \n\treturn impulse2(mod(x, period), k);\n    \n}\n\n// remap [0,1] -> [a, b])\nfloat remap(float x, float a, float b) {\n    return a*x+b;\n}\n\n\nfloat cyl(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sph(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat cylcap( vec3 p, float r, float h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat ring(vec3 p, float h, float rout, float rin) {\n    return max(cylcap(p, h, rout), -cylcap(p, 2.*h, rin));\n}\n\nfloat box(vec3 p, vec3 r) {\n    vec3 d = abs(p) - r;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n/*\n\tp = abs(p) - r;\n    return max(p.x, max(p.y, p.z));\n}\n*/\n\nvec2 repeat(vec2 p, vec2 s) {\n    \treturn (fract(p/s-.5)-.5)*s;\n}\n\nfloat repeat(float p, float s) {\n    \treturn (fract(p/s-.5)-.5)*s;\n}\n\nfloat sdOctopus(vec3 p) {\n    float s = 0.4;\n    vec3 q = p;\n    \n    \n    q.z = abs(q.z);\n     \n    q.y = -abs(q.y);\n    q.yz *= rot(PI*0.25);\n    q.z = abs(q.z);\n    q.y = -abs(q.y);\n    q.yz *= rot(PI*0.125);\n    q.z = abs(q.z);\n   \n    q.xz *= rot(-PI*0.25);\n\n    q.xz -= 0.5;\n \n    int maxIter = 20;\n    float d = 1e6;\n    float alpha = remap(continuesPulse((tt), 0.7, 4.0, 5.0), -0.45, 0.15);\n\n    for(int i=1; i < maxIter; i++) { \n        q.xz *= rot(-alpha);\n        q.z-=10./float(maxIter);\n        s -= 0.8/float(maxIter);\n        float b = box(q, vec3(s))-.01;\n        d = min(d, b);              \n    }\n    \n    float head = fIcosahedron(p, .7);\n    \n    d = min(d, head);\n  \n    return d;\n}\n\n\nvec3 tunnel(vec3 p) {\n\tvec3 off = vec3(0);\n    off.x += sin(p.z*.1)*4.;\n    off.y += sin(p.z*.12)*3.;\n    return off;\n}\n\nvec2 moda(vec2 p, float s) {\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    a = (fract(a/s-.5)-.5)*s;\n    return r*vec2(cos(a), sin(a));\n       \n}\n\nfloat repeat2(inout float p, float size) {\n  float c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nvoid cam(inout vec3 p) {\n\tp.z += tt*5.;// + 7.*sin(.1*tt);\n    p -= tunnel(p);\n}\n\nfloat map(vec3 p) {\n\n    vec3 np = p;\n\n    float tunr = 10.;\n    float vrep = 10.;\n    \n    p += tunnel(p);\n   \n    vec3 vvp = p;\n    vvp.z += vrep/2.;\n    cid = 1.+(repeat2(vvp.z, vrep)/vrep)*10.;\n    float octo;\n    \n    {\n    \n        vec3 q = p;\n        float pulse = continuesPulse((tt), 0.7, 3.0, 5.0);\n        float pulse2 = continuesPulse2((tt-1.), 3., 5.0);\n  \n        q.z += 5.;\n        \n        q.z -= remap(pulse, 1.5, 10.0);   \\\n        q.z -= 1.5*tt + tt *remap(pulse2, 0., 3.5);\n                \n       // float oid = repeat2(q.z, 30.);\n        q.xz *= rot(-PI*.5);\n        vec3 o1 = q;\n        vec3 o2 = q;\n\n        o1.xy += vec2(-4.5*sin(tt), 3.3*cos(.4*tt));\n        //o2.x -= 5.0;\n\n        o1.xz *= rot(.4*sin(tt*.4));\n        float s = 1.8;\n        octo = 1./s*sdOctopus(o1/s);\n    }\n\n    vec3 bp = p;\n    vec3 vp = p;\n    vec3 cp = p;\n    vec3 sp = p;\n    \n\t\n    bp.x = atan(p.y, p.x)*30./3.1415;\n    bp.y = length(p.xy)-tunr;\n\n    \n    bp.xz = repeat(bp.xz, vec2(4));\n    bp.xz = abs(bp.xz) - 1.; \n    bp.x -= bp.z*.4;\n     \n    for(float i = 0.; i < 3.; i += 1.) {\n        bp.xz *= rot(tt*.1+cid);\n        //bp.yz *= rot(5.*i);\n      \n        bp.xz = abs(bp.xz) - 1. - .1*SIN(i*tt*.3);\n\n        bp.x += .1;\n \n    }\n      \n    float b = .9*box(bp, vec3(.8));\n\n\n    float dz = abs(ro.z-np.z);\n    float fade = exp(-sqrt(dz)*.4);\n    \n    cp.xy *= rot(.08*p.z);\n    cp.x = abs(cp.x) - 3.;\n    cp.x += sin(0.25*cp.y+sin(tt))*2.;\n    cp.z = repeat(cp.z, 5.);\n    \n    float vid = repeat2(vp.z, vrep);\n    vp.yz *= rot(PI*.5);\n    float veil = ring(vp, max(0., .01), tunr, tunr-.1);\n    \n    float gls = SIN(vid*2.+2.*tt);\n    gl += .018/(.1+pow(abs(veil), 8.));\n    \n    float tun = b;\n    \n   // repeat2(sp.z, vrep);\n    //sp.y -= 9.4;\n    //sp.z -= vrep/2.;\n    //float stone = .3*fIcosahedron(sp, 1.5);\n\n    mat = tun < octo ? 0. : 1.+cid;\n    \n    float d = min(tun, octo);\n    return d;\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    tt = 1.5*iTime;\n    \n    vec3 ls = vec3(0, 0, -10.0); // light source\n\tvec3 col = vec3(0);\n    \n    ro = vec3(0, 0, -20);\n    vec3 rd = normalize(vec3(-uv, .7)); \n    \n    vec3 gcol = vec3(0.467,0.706,0.933);\n\n    cam(ro);\n    cam(ls);\n    vec3 p = ro;\n    float d = 0.1;\n    \n    float l_mat = 0.;\n    float l_cid = 0.;\n    \n    float i, t= .1;\n    for(i=0.; i<150.; i++) {\n        d = map(p);\n        \n        if(d < 0.001 || d > 20.) break;\n        \n        p += d*rd;\n        t += d;\n        l_mat = mat;\n        l_cid = cid;     \n    }\n    \n    if(d < 0.001) {\n        vec2 e = vec2(0.0035, -0.0035);\n        \n        vec3 al = pal(l_cid);\n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        \n        vec3 l = normalize(ls-p);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n        float sss = smoothstep(0., 1., map(p+l*.4))/.4;\n        float ao = calcAO(p, n);\n\n        if(l_mat < 1.) {\n           // gcol = mix(gcol, al, .2);\n            col += pow(i/100., 1.2)*3.*gcol*exp(-t*t*0.001);\n        } else {\n            col +=  .2*spe+.8*al*(.3+.8*dif+1.5*sss) + .2*ao;\n          \n          \n        }\n    }\n    \n    col += 0.08*gl*gcol;\n           \n    col = pow(col, vec3(1.4));\n    fragColor = vec4(col,1.0);\n}"
    }, 
    "Fractal Noise": {
      "name": "Fractal Noise",
      "category": "FRACTAL PRESETS",
      "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv00 = fragCoord / iResolution.xy; //Original UV\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y; //Fractal Circle UV\n    vec2 uv0 = uv; //Circle UV\n    vec3 finalcol = vec3  (0.0);\n    float time = iTime; //Animation Speed\n\n    // Access webcam texture\n    vec3 camcol = texture(iChannel0, uv00).rgb;\n    \n    for (float i = 0.0; i < 4.0; i++) {\n    \n        uv = fract(uv * 1.5) - 0.5;\n        float d = length(uv) * exp(-length(uv0 * 1.5));\n        float d0 = length(uv0);\n        d = sin(d * (i + abs(cos(time)) - time * 0.5) + time) / 8.0;\n        d = smoothstep(0.01 / d, 1.5, d);\n        \n        float colr = sin(time * 2.0) * 0.3 + (uv.x * sin(time) * 0.1);\n        float colg = 0.4 / d0 * 0.1 - (uv.y * sin(time) * 0.1);\n        float colb = cos(time * 2.0) * cos(time) * (d0 * sin(time) * 0.2);\n        if (i >= 3.0) colb = colr;\n        vec3 col = vec3(colr, colg, colb);\n        finalcol += col * (d + abs(cos(time) * 0.1));\n        \n        camcol = smoothstep(-.1,.9,camcol);\n    }\n    // Combine final color with webcam texture\n    camcol-= finalcol*2.;\n    finalcol -= camcol*finalcol;\n\n    fragColor = vec4(finalcol, 1.0);\n}"
    },
    "Trippy Waves": {
      "name": "Trippy Waves",
      "category": "FRACTAL PRESETS",
      "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 0.5;\n\tvec2 uv = zoom * (fragCoord.xy - iResolution.xy / 2.0);\n        \n    float t = iTime * 3.1415;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \n    float pi = acos(-1.);\n        \n   \n    float m = 1.;\n    float n = 8.;\n    float p = 1.;\n    \n    float r = sqrt(x*x+y*y);\n    float th = atan(y, x);\n   \n    \n    float value = 0.;\n    \n    const int points = 7;\n    \n    for(int i = 0; i < points ; i++){\n      float angle = pi / float(points) * float(i);\n\n      float w = x * sin(angle) + y * cos(angle);\n\n\t  value += sin(w + t);\n    };\n\n        \n    float color = (sin(value * pi / 2.) + 1.) * 1.5;\n    \n    if(color > 0.0) {\n      fragColor = color - vec4(0,1.5,2,0); \n    } else {\n      //fragColor = vec4(med, med, low,1.0);\n      fragColor = -color - vec4(1,1.5,0,0); \n    }\n}"
    },
    "waves": {
      "name": "Quantum Waves",
      "category": "SHADER PRESETS",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float d = length(p);\n    float angle = atan(p.y, p.x);\n    \n    float wave1 = sin(d * 15.0 - time * 3.0) * 0.5 + 0.5;\n    float wave2 = sin(d * 20.0 + time * 2.0) * 0.5 + 0.5;\n    float wave3 = sin(angle * 8.0 + time) * 0.5 + 0.5;\n    \n    float pattern = wave1 * wave2 * wave3;\n    pattern *= exp(-d * 1.5);\n    \n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 1.0, 1.0) * pattern;\n    col += vec3(0.0, 0.5, 1.0) * wave1 * exp(-d * 2.0);\n    col += vec3(1.0, 0.0, 1.0) * wave2 * 0.3;\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    }      
  }
}    

    





   
    

    
    
