{
  "presets": {
    "plasma": {
      "name": "Plasma Field",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float v = 0.0;\n    v += sin(p.x * 10.0 + time);\n    v += sin(p.y * 10.0 + time * 1.2);\n    v += sin((p.x + p.y) * 10.0 + time * 0.8);\n    v += sin(length(p) * 15.0 - time * 2.0);\n    v *= 0.25;\n    \n    vec3 col = vec3(\n        sin(v * 3.14159 + time * 0.5),\n        sin(v * 3.14159 + 2.094 + time * 0.3),\n        sin(v * 3.14159 + 4.189 + time * 0.7)\n    );\n    col = col * 0.5 + 0.5;\n    col = pow(col, vec3(1.5));\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "waves": {
      "name": "Quantum Waves",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float d = length(p);\n    float angle = atan(p.y, p.x);\n    \n    float wave1 = sin(d * 15.0 - time * 3.0) * 0.5 + 0.5;\n    float wave2 = sin(d * 20.0 + time * 2.0) * 0.5 + 0.5;\n    float wave3 = sin(angle * 8.0 + time) * 0.5 + 0.5;\n    \n    float pattern = wave1 * wave2 * wave3;\n    pattern *= exp(-d * 1.5);\n    \n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 1.0, 1.0) * pattern;\n    col += vec3(0.0, 0.5, 1.0) * wave1 * exp(-d * 2.0);\n    col += vec3(1.0, 0.0, 1.0) * wave2 * 0.3;\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "galaxy": {
      "name": "Galaxy Spiral",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float angle = atan(p.y, p.x);\n    float radius = length(p);\n    \n    float spiral = angle + radius * 5.0 - time * 0.5;\n    float arms = sin(spiral * 3.0) * exp(-radius * 0.8);\n    arms = smoothstep(0.0, 1.0, arms * 0.5 + 0.5);\n    \n    float stars = step(0.97, hash(floor(uv * 200.0)));\n    stars *= exp(-radius * 1.5);\n    \n    vec3 core = vec3(1.0, 0.8, 0.5) * exp(-radius * 3.0);\n    vec3 armColor = vec3(0.3, 0.5, 1.0) * arms;\n    vec3 starColor = vec3(1.0) * stars;\n    \n    vec3 col = core + armColor + starColor;\n    col += vec3(0.05, 0.02, 0.1);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "matrix": {
      "name": "Matrix Rain",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    \n    float cols = 60.0;\n    float rows = 40.0;\n    \n    vec2 grid = vec2(floor(uv.x * cols), floor(uv.y * rows));\n    float colId = grid.x;\n    \n    float speed = hash(vec2(colId, 0.0)) * 2.0 + 0.5;\n    float offset = hash(vec2(colId, 1.0)) * 100.0;\n    \n    float y = fract((uv.y + time * speed * 0.15 + offset));\n    float charY = floor(y * rows) / rows;\n    \n    float char = hash(vec2(colId, charY + floor(time * speed)));\n    float intensity = char * (1.0 - y);\n    \n    float head = smoothstep(0.98, 1.0, y);\n    \n    vec3 col = vec3(0.0, intensity, 0.0);\n    col += vec3(0.5, 1.0, 0.5) * head;\n    col *= smoothstep(0.0, 0.05, y);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "fire": {
      "name": "Procedural Fire",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nfloat fbm(vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    for(int i = 0; i < 6; i++) {\n        value += amplitude * noise(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = uv;\n    \n    p.y -= time * 0.2;\n    \n    float n = fbm(p * 3.0 + time * 0.5);\n    n = pow(n, 2.0) * (1.5 - uv.y);\n    \n    vec3 col = vec3(0.0);\n    col += vec3(1.0, 1.0, 0.5) * pow(n, 3.0) * 2.0;\n    col += vec3(1.0, 0.3, 0.0) * n * n;\n    col += vec3(0.5, 0.0, 0.0) * n;\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "electric": {
      "name": "Electric Orbs",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    for(float i = 0.0; i < 8.0; i++) {\n        float angle = time * (0.5 + i * 0.1) + i * 0.8;\n        vec2 pos = vec2(cos(angle), sin(angle)) * 0.5;\n        float d = length(p - pos);\n        \n        float glow = 0.015 / d;\n        vec3 color = vec3(0.2, 0.5 + sin(time + i) * 0.5, 1.0);\n        col += color * glow;\n    }\n    \n    col += vec3(0.5, 0.8, 1.0) * pow(col.b, 2.0);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "tunnel": {
      "name": "Infinite Tunnel",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float angle = atan(p.y, p.x);\n    float radius = length(p);\n    \n    vec2 tuv = vec2(angle / 3.14159, 0.5 / radius);\n    tuv.y -= time * 0.5;\n    tuv.x += time * 0.2;\n    \n    float pattern1 = sin(tuv.x * 20.0) * sin(tuv.y * 20.0);\n    float pattern2 = sin(tuv.x * 15.0 + tuv.y * 15.0);\n    \n    float final = pattern1 * pattern2;\n    final = final * 0.5 + 0.5;\n    \n    vec3 col = vec3(final);\n    col *= vec3(0.2, 0.8, 1.0);\n    col *= 1.0 - radius * 0.6;\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "fractal": {
      "name": "Fractal Noise",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 2.0;\n    p.x *= resolution.x / resolution.y;\n    \n    float n = 0.0;\n    float amp = 0.5;\n    vec2 pos = p * 2.0;\n    \n    for(int i = 0; i < 5; i++) {\n        n += noise(pos + time * 0.3) * amp;\n        pos *= 2.0;\n        amp *= 0.5;\n    }\n    \n    vec3 col = vec3(n);\n    col = pow(col, vec3(1.5));\n    col *= vec3(0.5 + sin(time) * 0.5, 0.7, 1.0);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "hexagon": {
      "name": "Hexagon Grid",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvec2 hexCoord(vec2 p) {\n    vec2 r = vec2(1.0, 1.732);\n    vec2 h = r * 0.5;\n    vec2 a = mod(p, r) - h;\n    vec2 b = mod(p - h, r) - h;\n    return dot(a, a) < dot(b, b) ? a : b;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = (uv - 0.5) * 10.0;\n    p.x *= resolution.x / resolution.y;\n    \n    vec2 hc = hexCoord(p);\n    float d = length(hc);\n    \n    float hex = smoothstep(0.5, 0.48, d);\n    float pulse = sin(d * 3.0 - time * 2.0) * 0.5 + 0.5;\n    \n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 1.0, 1.0) * hex * 0.5;\n    col += vec3(0.0, 0.5, 1.0) * hex * pulse;\n    col += vec3(1.0, 0.0, 1.0) * (1.0 - smoothstep(0.48, 0.5, d)) * 0.5;\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "voronoi": {
      "name": "Voronoi Cells",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nvec2 hash2(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = uv * 8.0;\n    p.x *= resolution.x / resolution.y;\n    \n    vec2 gv = fract(p);\n    vec2 id = floor(p);\n    \n    float minDist = 100.0;\n    vec2 minPoint;\n    \n    for(float y = -1.0; y <= 1.0; y++) {\n        for(float x = -1.0; x <= 1.0; x++) {\n            vec2 offset = vec2(x, y);\n            vec2 neighbor = hash2(id + offset);\n            neighbor += offset;\n            neighbor += sin(time + neighbor * 6.28) * 0.3;\n            \n            float dist = length(gv - neighbor);\n            if(dist < minDist) {\n                minDist = dist;\n                minPoint = neighbor;\n            }\n        }\n    }\n    \n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 1.0, 0.5) * (1.0 - minDist);\n    col += vec3(0.0, 0.5, 1.0) * smoothstep(0.02, 0.0, minDist);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    },
    "glitch": {
      "name": "Digital Glitch",
      "code": "uniform vec2 resolution;\nuniform float time;\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    \n    float glitchStrength = step(0.9, hash(vec2(time * 0.5)));\n    float blockY = floor(uv.y * 20.0);\n    float glitchOffset = (hash(vec2(blockY, floor(time * 10.0))) - 0.5) * 0.1 * glitchStrength;\n    \n    vec2 glitchUV = uv;\n    glitchUV.x += glitchOffset;\n    \n    vec3 col = vec3(0.0);\n    col.r = step(0.5, fract(glitchUV.x * 10.0 + time));\n    col.g = step(0.5, fract(glitchUV.y * 10.0 - time));\n    col.b = step(0.5, fract((glitchUV.x + glitchUV.y) * 10.0));\n    \n    col *= vec3(0.0, 1.0, 1.0);\n    \n    float scanline = sin(uv.y * resolution.y * 0.5) * 0.1;\n    col += scanline;\n    \n    gl_FragColor = vec4(col, 1.0);\n}"
    }
  }
}